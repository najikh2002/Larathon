"""
Larathon Application Bundle
Auto-generated by: python artisan.py build
DO NOT EDIT THIS FILE MANUALLY
"""

# External Dependencies
from botocore.config import Config
from datetime import datetime
from datetime import datetime, timedelta
from dotenv import load_dotenv
from fastapi import APIRouter, Request
from fastapi import APIRouter, Request, Form
from fastapi import FastAPI
from fastapi import Request
from fastapi import UploadFile, File, Form
from fastapi.responses import JSONResponse
from fastapi.responses import RedirectResponse
from fastapi.responses import Response
from fastapi.staticfiles import StaticFiles
from inspect import signature
from jinja2 import Environment, FileSystemLoader
from jinja2 import Environment, FileSystemLoader, select_autoescape
from pathlib import Path
from sqlalchemy import Column, Integer, String, TIMESTAMP
from sqlalchemy import create_engine
from sqlalchemy import text
from sqlalchemy.orm import declarative_base
from sqlalchemy.orm import sessionmaker
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy_utils import database_exists, create_database
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.requests import Request
from starlette.responses import JSONResponse
from starlette.responses import JSONResponse, RedirectResponse
from starlette.responses import RedirectResponse
from starlette.responses import RedirectResponse, JSONResponse
from starlette.templating import Jinja2Templates
from typing import Callable, List, Dict, Optional
from typing import List, Dict, Callable, Optional
from typing import Optional
from typing import Optional, BinaryIO
from typing import Optional, Dict
from typing import Optional, List, Dict, Any
from typing import Union, BinaryIO
import asyncio
import bcrypt
import boto3
import importlib
import importlib.util
import inspect
import io
import jwt
import os
import os, importlib.util
import psycopg2
import psycopg2.extras
import re
import requests
import shutil
import traceback
import warnings


# ================================================================================
# File: config/app.py
# ================================================================================
APP_NAME = os.getenv("APP_NAME", "LaravelFastAPI")
APP_ENV = os.getenv("APP_ENV", "local")
APP_DEBUG = os.getenv("APP_DEBUG", "false").lower() == "true"
APP_PORT = int(os.getenv("APP_PORT", "8000"))

# ================================================================================
# File: config/database.py
# ================================================================================
def get_database_url():
    """
    Generate database URL based on DB_CONNECTION environment variable.
    Supports: sqlite, mysql, pgsql (PostgreSQL)
    """
    conn = os.getenv("DB_CONNECTION", "sqlite")

    if conn == "sqlite":
        db = os.getenv("DB_DATABASE", "database.sqlite")
        return f"sqlite:///{db}"

    elif conn == "mysql":
        user = os.getenv("DB_USERNAME", "root")
        pwd = os.getenv("DB_PASSWORD", "")
        host = os.getenv("DB_HOST", "127.0.0.1")
        port = os.getenv("DB_PORT", "3306")
        db = os.getenv("DB_DATABASE", "test")
        return f"mysql+pymysql://{user}:{pwd}@{host}:{port}/{db}"

    elif conn == "pgsql" or conn == "postgresql":
        user = os.getenv("DB_USERNAME", "postgres")
        pwd = os.getenv("DB_PASSWORD", "")
        host = os.getenv("DB_HOST", "127.0.0.1")
        port = os.getenv("DB_PORT", "5432")
        db = os.getenv("DB_DATABASE", "postgres")
        return f"postgresql+psycopg2://{user}:{pwd}@{host}:{port}/{db}"

    else:
        raise Exception(f"Unsupported DB_CONNECTION: {conn}. Supported: sqlite, mysql, pgsql")

def get_engine():
    """
    Create SQLAlchemy engine based on database configuration.
    """
    db_url = get_database_url()
    return create_engine(db_url)

# ================================================================================
# File: config/filesystems.py
# ================================================================================
"""
Filesystem Configuration
Laravel-style storage configuration for multiple storage drivers
"""

# Default filesystem disk
default = os.getenv("FILESYSTEM_DISK", "local")

# Filesystem disks configuration
disks = {
    # ==========================================
    # Local Storage (Development)
    # ==========================================
    "local": {
        "driver": "local",
        "root": os.path.join(os.getcwd(), "storage", "app"),
        "url": "/storage",
        "visibility": "private",
    },
    
    "public": {
        "driver": "local",
        "root": os.path.join(os.getcwd(), "storage", "app", "public"),
        "url": "/storage",
        "visibility": "public",
    },
    
    # ==========================================
    # Supabase Storage (Recommended for Serverless)
    # ==========================================
    "supabase": {
        "driver": "supabase",
        "url": os.getenv("SUPABASE_URL"),
        "key": os.getenv("SUPABASE_KEY"),
        "bucket": os.getenv("SUPABASE_BUCKET", "larathon"),
        "visibility": "public",
    },
    
    # ==========================================
    # S3-Compatible Storage
    # Universal driver for all S3-compatible services
    # ==========================================
    
    # AWS S3 (Original)
    "s3": {
        "driver": "s3",
        "key": os.getenv("AWS_ACCESS_KEY_ID"),
        "secret": os.getenv("AWS_SECRET_ACCESS_KEY"),
        "region": os.getenv("AWS_DEFAULT_REGION", "us-east-1"),
        "bucket": os.getenv("AWS_BUCKET"),
        "url": os.getenv("AWS_URL"),  # CloudFront URL if using CDN
        "visibility": "public",
    },
    
    # Cloudflare R2
    "r2": {
        "driver": "s3",
        "key": os.getenv("R2_ACCESS_KEY_ID"),
        "secret": os.getenv("R2_SECRET_ACCESS_KEY"),
        "region": "auto",  # R2 uses auto region
        "bucket": os.getenv("R2_BUCKET"),
        "endpoint": os.getenv("R2_ENDPOINT"),
        "url": os.getenv("R2_PUBLIC_URL"),  # Custom domain
        "visibility": "public",
    },
    
    # MinIO (Self-hosted S3)
    "minio": {
        "driver": "s3",
        "key": os.getenv("MINIO_ACCESS_KEY"),
        "secret": os.getenv("MINIO_SECRET_KEY"),
        "region": "us-east-1",
        "bucket": os.getenv("MINIO_BUCKET"),
        "endpoint": os.getenv("MINIO_ENDPOINT"),  # e.g., http://minio:9000
        "url": os.getenv("MINIO_PUBLIC_URL"),
        "use_path_style": True,  # MinIO requires path-style addressing
        "visibility": "public",
    },
    
    # DigitalOcean Spaces
    "spaces": {
        "driver": "s3",
        "key": os.getenv("SPACES_ACCESS_KEY"),
        "secret": os.getenv("SPACES_SECRET_KEY"),
        "region": os.getenv("SPACES_REGION", "nyc3"),
        "bucket": os.getenv("SPACES_BUCKET"),
        "endpoint": os.getenv("SPACES_ENDPOINT"),  # e.g., https://nyc3.digitaloceanspaces.com
        "url": os.getenv("SPACES_URL"),  # CDN URL
        "visibility": "public",
    },
    
    # Wasabi
    "wasabi": {
        "driver": "s3",
        "key": os.getenv("WASABI_ACCESS_KEY"),
        "secret": os.getenv("WASABI_SECRET_KEY"),
        "region": os.getenv("WASABI_REGION", "us-east-1"),
        "bucket": os.getenv("WASABI_BUCKET"),
        "endpoint": os.getenv("WASABI_ENDPOINT"),  # e.g., https://s3.wasabisys.com
        "url": os.getenv("WASABI_URL"),
        "visibility": "public",
    },
    
    # Backblaze B2
    "b2": {
        "driver": "s3",
        "key": os.getenv("B2_ACCESS_KEY"),
        "secret": os.getenv("B2_SECRET_KEY"),
        "region": os.getenv("B2_REGION", "us-west-002"),
        "bucket": os.getenv("B2_BUCKET"),
        "endpoint": os.getenv("B2_ENDPOINT"),  # e.g., https://s3.us-west-002.backblazeb2.com
        "url": os.getenv("B2_URL"),
        "visibility": "public",
    },
}

# Symbolic links (for serving public storage)
links = {
    "public/storage": "storage/app/public"
}

# ================================================================================
# File: vendor/Illuminate/Database/Migration.py
# ================================================================================
"""
Migration Base Class
"""


class Migration:
    """
    Base migration class
    
    Supports two styles:
    
    Style 1 - With self.execute():
        class CreateUsersTable(Migration):
            def up(self):
                self.execute('''
                    CREATE TABLE users (
                        id SERIAL PRIMARY KEY,
                        name VARCHAR(255)
                    )
                ''')
            
            def down(self):
                self.execute('DROP TABLE users')
    
    Style 2 - With engine parameter:
        class CreateUsersTable(Migration):
            def up(self, engine):
                with engine.connect() as conn:
                    conn.execute(text('CREATE TABLE users (...)'))
                    conn.commit()
    """
    
    def __init__(self):
        self._engine = None
    
    def set_engine(self, engine):
        """Set engine for self.execute() style"""
        self._engine = engine
    
    def execute(self, query):
        """Execute raw SQL - for self.execute() style migrations"""
        if not self._engine:
            raise RuntimeError("Engine not set. Use set_engine() first.")
        
        with self._engine.connect() as conn:
            conn.execute(text(query))
            conn.commit()
    
    def up(self, engine=None):
        """Run the migration - override this in child class"""
        if engine:
            self._engine = engine
        # Child classes should override this method
        pass
    
    def down(self, engine=None):
        """Rollback the migration - override this in child class"""
        if engine:
            self._engine = engine
        # Child classes should override this method
        pass

# ================================================================================
# File: vendor/Illuminate/Database/Model.py
# ================================================================================
"""
Base Model Class for Database Operations
Simple ORM-like functionality for database models
"""


class Model:
    """
    Base Model class for database operations
    
    Attributes:
        table: Table name (must be set in child class)
        fillable: List of fillable fields
        hidden: List of fields to hide in output
    """
    
    table = None  # Must be overridden in child class
    fillable = []
    hidden = []
    
    def __init__(self, **kwargs):
        """Initialize model with data"""
        for key, value in kwargs.items():
            setattr(self, key, value)
    
    @classmethod
    def get_connection(cls):
        """Get database connection"""
        db_url = get_database_url()
        
        # psycopg2 doesn't accept SQLAlchemy-style URLs
        # Remove +psycopg2 from the URL
        db_url = db_url.replace('postgresql+psycopg2://', 'postgresql://')
        db_url = db_url.replace('mysql+pymysql://', 'mysql://')
        
        conn = psycopg2.connect(db_url)
        return conn
    
    @classmethod
    async def all(cls) -> List['Model']:
        """Get all records"""
        conn = cls.get_connection()
        cursor = conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)
        
        try:
            cursor.execute(f"SELECT * FROM {cls.table}")
            rows = cursor.fetchall()
            return [cls(**dict(row)) for row in rows]
        finally:
            cursor.close()
            conn.close()
    
    @classmethod
    async def find(cls, id: int) -> Optional['Model']:
        """Find record by ID"""
        conn = cls.get_connection()
        cursor = conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)
        
        try:
            cursor.execute(f"SELECT * FROM {cls.table} WHERE id = %s", (id,))
            row = cursor.fetchone()
            return cls(**dict(row)) if row else None
        finally:
            cursor.close()
            conn.close()
    
    @classmethod
    def where(cls, column: str, value: Any):
        """Start a query builder (returns QueryBuilder)"""
        return QueryBuilder(cls, column, value)
    
    @classmethod
    async def create(cls, data: Dict[str, Any]) -> 'Model':
        """Create new record"""
        # Filter only fillable fields
        filtered_data = {k: v for k, v in data.items() if k in cls.fillable}
        
        conn = cls.get_connection()
        cursor = conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)
        
        try:
            columns = ', '.join(filtered_data.keys())
            placeholders = ', '.join(['%s'] * len(filtered_data))
            values = tuple(filtered_data.values())
            
            query = f"""
                INSERT INTO {cls.table} ({columns})
                VALUES ({placeholders})
                RETURNING *
            """
            
            cursor.execute(query, values)
            conn.commit()
            
            row = cursor.fetchone()
            return cls(**dict(row))
        finally:
            cursor.close()
            conn.close()
    
    async def save(self) -> bool:
        """Save (update) existing record"""
        if not hasattr(self, 'id'):
            raise ValueError("Cannot save model without ID")
        
        # Get fillable data
        data = {k: getattr(self, k) for k in self.fillable if hasattr(self, k)}
        
        conn = self.get_connection()
        cursor = conn.cursor()
        
        try:
            set_clause = ', '.join([f"{k} = %s" for k in data.keys()])
            values = tuple(data.values()) + (self.id,)
            
            query = f"""
                UPDATE {self.table}
                SET {set_clause}, updated_at = CURRENT_TIMESTAMP
                WHERE id = %s
            """
            
            cursor.execute(query, values)
            conn.commit()
            return True
        finally:
            cursor.close()
            conn.close()
    
    async def delete(self) -> bool:
        """Delete this record"""
        if not hasattr(self, 'id'):
            raise ValueError("Cannot delete model without ID")
        
        conn = self.get_connection()
        cursor = conn.cursor()
        
        try:
            cursor.execute(f"DELETE FROM {self.table} WHERE id = %s", (self.id,))
            conn.commit()
            return True
        finally:
            cursor.close()
            conn.close()
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert model to dictionary"""
        data = {}
        for key, value in self.__dict__.items():
            if key not in self.hidden and not key.startswith('_'):
                # Convert datetime to string
                if isinstance(value, datetime):
                    data[key] = value.isoformat()
                else:
                    data[key] = value
        return data
    
    def __repr__(self):
        return f"<{self.__class__.__name__} {self.to_dict()}>"


class QueryBuilder:
    """
    Simple query builder for Model
    Supports basic where and order_by operations
    """
    
    def __init__(self, model_class, column: str = None, value: Any = None):
        self.model_class = model_class
        self.wheres = []
        self.order_bys = []
        self.limit_value = None
        
        if column and value is not None:
            self.wheres.append((column, '=', value))
    
    def where(self, column: str, operator_or_value: Any, value: Any = None):
        """Add WHERE clause"""
        if value is None:
            # where('column', 'value') -> where('column', '=', 'value')
            operator = '='
            value = operator_or_value
        else:
            operator = operator_or_value
        
        self.wheres.append((column, operator, value))
        return self
    
    def order_by(self, column: str, direction: str = 'asc'):
        """Add ORDER BY clause"""
        self.order_bys.append((column, direction.upper()))
        return self
    
    def limit(self, limit: int):
        """Add LIMIT clause"""
        self.limit_value = limit
        return self
    
    async def get(self) -> List[Model]:
        """Execute query and get results"""
        conn = self.model_class.get_connection()
        cursor = conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)
        
        try:
            query = f"SELECT * FROM {self.model_class.table}"
            params = []
            
            # Add WHERE clauses
            if self.wheres:
                where_parts = []
                for column, operator, value in self.wheres:
                    where_parts.append(f"{column} {operator} %s")
                    params.append(value)
                query += " WHERE " + " AND ".join(where_parts)
            
            # Add ORDER BY
            if self.order_bys:
                order_parts = [f"{col} {direction}" for col, direction in self.order_bys]
                query += " ORDER BY " + ", ".join(order_parts)
            
            # Add LIMIT
            if self.limit_value:
                query += f" LIMIT {self.limit_value}"
            
            cursor.execute(query, tuple(params))
            rows = cursor.fetchall()
            return [self.model_class(**dict(row)) for row in rows]
        finally:
            cursor.close()
            conn.close()
    
    async def first(self) -> Optional[Model]:
        """Get first result"""
        self.limit_value = 1
        results = await self.get()
        return results[0] if results else None
    
    async def count(self) -> int:
        """Count matching records"""
        conn = self.model_class.get_connection()
        cursor = conn.cursor()
        
        try:
            query = f"SELECT COUNT(*) FROM {self.model_class.table}"
            params = []
            
            if self.wheres:
                where_parts = []
                for column, operator, value in self.wheres:
                    where_parts.append(f"{column} {operator} %s")
                    params.append(value)
                query += " WHERE " + " AND ".join(where_parts)
            
            cursor.execute(query, tuple(params))
            return cursor.fetchone()[0]
        finally:
            cursor.close()
            conn.close()

# ================================================================================
# File: vendor/Illuminate/Auth/JWT.py
# ================================================================================
"""
JWT Authentication Helper
"""


class JWT:
    """JWT token generator and validator"""
    
    @staticmethod
    def get_secret() -> str:
        """Get JWT secret from environment"""
        secret = os.getenv('SECRET_KEY', 'your-secret-key-change-this')
        if secret == 'your-secret-key-change-this':
            warnings.warn("Using default SECRET_KEY! Set SECRET_KEY in .env for production!")
        return secret
    
    @staticmethod
    def generate(user_id: int, email: str, role: str = 'user', expires_in: int = 24) -> str:
        """
        Generate JWT token
        
        Args:
            user_id: User ID
            email: User email
            role: User role (default: 'user')
            expires_in: Token expiration in hours (default: 24)
        
        Returns:
            JWT token string
        """
        payload = {
            'user_id': user_id,
            'email': email,
            'role': role,
            'exp': datetime.utcnow() + timedelta(hours=expires_in),
            'iat': datetime.utcnow()
        }
        
        token = jwt.encode(payload, JWT.get_secret(), algorithm='HS256')
        return token
    
    @staticmethod
    def decode(token: str) -> Optional[Dict]:
        """
        Decode and validate JWT token
        
        Args:
            token: JWT token string
        
        Returns:
            Decoded payload dict or None if invalid
        """
        try:
            payload = jwt.decode(token, JWT.get_secret(), algorithms=['HS256'])
            return payload
        except jwt.ExpiredSignatureError:
            return None  # Token expired
        except jwt.InvalidTokenError:
            return None  # Invalid token
    
    @staticmethod
    def verify(token: str) -> bool:
        """
        Verify if token is valid
        
        Args:
            token: JWT token string
        
        Returns:
            True if valid, False otherwise
        """
        return JWT.decode(token) is not None
    
    @staticmethod
    def extract_from_header(auth_header: Optional[str]) -> Optional[str]:
        """
        Extract token from Authorization header
        
        Args:
            auth_header: Authorization header value (e.g., "Bearer token123")
        
        Returns:
            Token string or None
        """
        if not auth_header:
            return None
        
        parts = auth_header.split()
        if len(parts) != 2 or parts[0].lower() != 'bearer':
            return None
        
        return parts[1]

# ================================================================================
# File: vendor/Illuminate/Console/Kernel.py
# ================================================================================
class Kernel:
    def __init__(self):
        self.commands = {
            "migrate": MigrateCommand(),
            "make:migration": MakeMigrationCommand(),
        }

    def handle(self, argv):
        if len(argv) < 2:
            print("âŒ No command given")
            return

        cmd = argv[1]
        args = argv[2:]

        if cmd in self.commands:
            self.commands[cmd].handle(args)
        else:
            print(f"âŒ Command {cmd} not found")

# ================================================================================
# File: vendor/Illuminate/Database/Connection.py
# ================================================================================
# Illuminate/Database/Connection.py

def get_engine(echo=False):
    db_url = get_database_url()
    engine = create_engine(db_url, echo=echo)

    if not database_exists(engine.url):
        print(f"âš¡ Database not found. Creating: {engine.url.database}")
        create_database(engine.url)

    return engine

# ================================================================================
# File: vendor/Illuminate/Database/Migrations/MigrationRunner.py
# ================================================================================
class MigrationRunner:
    def __init__(self):
        self.conn = psycopg2.connect(
            dbname=env("DB_DATABASE"),
            user=env("DB_USERNAME"),
            password=env("DB_PASSWORD"),
            host=env("DB_HOST"),
            port=env("DB_PORT"),
        )
        self.conn.autocommit = True
        self.cursor = self.conn.cursor()

        # Pastikan tabel migrations ada
        self.cursor.execute("""
            CREATE TABLE IF NOT EXISTS migrations (
                id SERIAL PRIMARY KEY,
                migration VARCHAR(255) NOT NULL UNIQUE,
                batch INT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)

    def run(self):
        migrations_path = os.path.join(os.getcwd(), "database/migrations")
        files = sorted([f for f in os.listdir(migrations_path) if f.endswith(".py")])

        # Ambil batch terakhir
        self.cursor.execute("SELECT COALESCE(MAX(batch), 0) FROM migrations")
        current_batch = self.cursor.fetchone()[0] + 1

        for file in files:
            migration_name = file.replace(".py", "")

            # cek apakah sudah dieksekusi
            self.cursor.execute("SELECT 1 FROM migrations WHERE migration = %s", (migration_name,))
            if self.cursor.fetchone():
                print(f"âš ï¸ Skipped: {migration_name} already migrated")
                continue

            print(f"ðŸ”¼ Running migration: {migration_name}")
            module = __import__(f"database.migrations.{migration_name}", fromlist=["Migration"])
            migration = module.Migration()
            migration.up(self.cursor)

            self.cursor.execute(
                "INSERT INTO migrations (migration, batch) VALUES (%s, %s)",
                (migration_name, current_batch),
            )

        self.cursor.close()
        self.conn.close()

# ================================================================================
# File: vendor/Illuminate/Database/Migrator.py
# ================================================================================
class Migrator:
    def __init__(self):
        self.engine = get_engine()
        self.migrations_path = os.path.join(os.getcwd(), "database", "migrations")

    def run(self):
        if not os.path.exists(self.migrations_path):
            print("âŒ No migrations directory found.")
            return

        for file in sorted(os.listdir(self.migrations_path)):
            if file.endswith(".py") and file != "__init__.py":
                migration_name = file.replace(".py", "")
                file_path = os.path.join(self.migrations_path, file)

                spec = importlib.util.spec_from_file_location(migration_name, file_path)
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)

                if hasattr(module, "up"):
                    print(f"ðŸ”¼ Running migration: {migration_name}")
                    module.up(self.engine)
                else:
                    print(f"âš ï¸ No up() method in {migration_name}")

# ================================================================================
# File: vendor/Illuminate/Filesystem/Drivers/LocalDriver.py
# ================================================================================
"""
Local Filesystem Driver
For local development and testing
"""


class LocalDriver:
    """Local filesystem driver"""
    
    def __init__(self, config: dict):
        self.root = config.get("root", "storage/app")
        self.url_prefix = config.get("url", "/storage")
        self.visibility = config.get("visibility", "private")
        
        # Ensure root directory exists
        Path(self.root).mkdir(parents=True, exist_ok=True)
    
    def put(self, path: str, contents: Union[str, bytes, BinaryIO]) -> bool:
        """Store a file"""
        try:
            full_path = self._full_path(path)
            
            # Create directory if needed
            Path(full_path).parent.mkdir(parents=True, exist_ok=True)
            
            # Write file
            if isinstance(contents, str):
                with open(full_path, 'w') as f:
                    f.write(contents)
            elif isinstance(contents, bytes):
                with open(full_path, 'wb') as f:
                    f.write(contents)
            else:  # File-like object
                with open(full_path, 'wb') as f:
                    shutil.copyfileobj(contents, f)
            
            return True
        except Exception as e:
            print(f"Error storing file: {e}")
            return False
    
    def get(self, path: str) -> bytes:
        """Get file contents"""
        full_path = self._full_path(path)
        with open(full_path, 'rb') as f:
            return f.read()
    
    def exists(self, path: str) -> bool:
        """Check if file exists"""
        return os.path.exists(self._full_path(path))
    
    def delete(self, path: str) -> bool:
        """Delete a file"""
        try:
            full_path = self._full_path(path)
            if os.path.exists(full_path):
                os.remove(full_path)
            return True
        except Exception as e:
            print(f"Error deleting file: {e}")
            return False
    
    def url(self, path: str) -> str:
        """Get public URL for file"""
        # For local development, return URL that can be served
        return f"{self.url_prefix}/{path}"
    
    def path(self, path: str) -> str:
        """Get full filesystem path"""
        return self._full_path(path)
    
    def files(self, directory: str = "") -> list:
        """List files in directory"""
        full_path = self._full_path(directory)
        
        if not os.path.exists(full_path):
            return []
        
        result = []
        for item in os.listdir(full_path):
            item_path = os.path.join(full_path, item)
            if os.path.isfile(item_path):
                # Return relative path
                rel_path = os.path.join(directory, item) if directory else item
                result.append(rel_path)
        
        return result
    
    def directories(self, directory: str = "") -> list:
        """List directories"""
        full_path = self._full_path(directory)
        
        if not os.path.exists(full_path):
            return []
        
        result = []
        for item in os.listdir(full_path):
            item_path = os.path.join(full_path, item)
            if os.path.isdir(item_path):
                rel_path = os.path.join(directory, item) if directory else item
                result.append(rel_path)
        
        return result
    
    def size(self, path: str) -> int:
        """Get file size in bytes"""
        return os.path.getsize(self._full_path(path))
    
    def _full_path(self, path: str) -> str:
        """Get full filesystem path"""
        # Remove leading slashes
        path = path.lstrip('/')
        return os.path.join(self.root, path)

# ================================================================================
# File: vendor/Illuminate/Filesystem/Drivers/S3Driver.py
# ================================================================================
"""
S3-Compatible Driver
Universal driver for all S3-compatible storage services:
- AWS S3
- Cloudflare R2
- MinIO
- DigitalOcean Spaces
- Wasabi
- Backblaze B2
- Supabase Storage (S3 mode)
- Any S3-compatible object storage
"""


class S3Driver:
    """
    Universal S3-compatible storage driver
    
    Supports any S3-compatible object storage service by providing
    the appropriate endpoint URL and credentials.
    """
    
    def __init__(self, config: dict):
        self.key = config.get("key")
        self.secret = config.get("secret")
        self.region = config.get("region", "auto")
        self.bucket = config.get("bucket")
        self.endpoint = config.get("endpoint")
        self.url = config.get("url")
        self.visibility = config.get("visibility", "public")
        self.use_path_style = config.get("use_path_style", False)  # For MinIO compatibility
        
        if not self.key or not self.secret or not self.bucket:
            raise ValueError("S3 credentials (key, secret) and bucket are required")
        
        # Initialize boto3 client
        try:
            
            # Configure boto3
            boto_config = Config(
                signature_version='s3v4',
                s3={'addressing_style': 'path' if self.use_path_style else 'auto'}
            )
            
            # Create S3 client
            client_kwargs = {
                'service_name': 's3',
                'aws_access_key_id': self.key,
                'aws_secret_access_key': self.secret,
                'config': boto_config
            }
            
            # Add endpoint if provided (for non-AWS S3)
            if self.endpoint:
                client_kwargs['endpoint_url'] = self.endpoint
            
            # Add region
            if self.region and self.region != 'auto':
                client_kwargs['region_name'] = self.region
            
            self.client = boto3.client(**client_kwargs)
            
        except ImportError:
            raise ImportError(
                "boto3 is required for S3 driver.\n"
                "Install: pip install boto3\n"
                "Add to requirements.txt: boto3==1.34.0"
            )
    
    def put(self, path: str, contents: Union[str, bytes, BinaryIO]) -> bool:
        """Store a file in S3"""
        try:
            path = path.lstrip('/')
            
            # Convert contents to bytes
            if isinstance(contents, str):
                file_data = contents.encode('utf-8')
            elif isinstance(contents, bytes):
                file_data = contents
            else:  # File-like object
                file_data = contents.read()
                if isinstance(file_data, str):
                    file_data = file_data.encode('utf-8')
            
            # Detect content type
            content_type = self._get_content_type(path)
            
            # Upload
            self.client.put_object(
                Bucket=self.bucket,
                Key=path,
                Body=file_data,
                ContentType=content_type,
                ACL='public-read' if self.visibility == 'public' else 'private'
            )
            
            return True
            
        except Exception as e:
            print(f"Error uploading to S3: {e}")
            return False
    
    def get(self, path: str) -> bytes:
        """Get file contents"""
        path = path.lstrip('/')
        
        response = self.client.get_object(
            Bucket=self.bucket,
            Key=path
        )
        
        return response['Body'].read()
    
    def exists(self, path: str) -> bool:
        """Check if file exists"""
        try:
            path = path.lstrip('/')
            self.client.head_object(
                Bucket=self.bucket,
                Key=path
            )
            return True
        except:
            return False
    
    def delete(self, path: str) -> bool:
        """Delete a file"""
        try:
            path = path.lstrip('/')
            self.client.delete_object(
                Bucket=self.bucket,
                Key=path
            )
            return True
        except Exception as e:
            print(f"Error deleting file: {e}")
            return False
    
    def url(self, path: str) -> str:
        """Get public URL for file"""
        path = path.lstrip('/')
        
        if self.url:
            # Custom public URL
            return f"{self.url}/{path}"
        elif self.endpoint:
            # Endpoint-based URL
            return f"{self.endpoint}/{self.bucket}/{path}"
        else:
            # AWS S3 URL
            return f"https://{self.bucket}.s3.{self.region}.amazonaws.com/{path}"
    
    def path(self, path: str) -> str:
        """Get 'path' (returns URL for S3)"""
        return self.url(path)
    
    def files(self, directory: str = "") -> list:
        """List files in directory"""
        try:
            directory = directory.lstrip('/')
            if directory and not directory.endswith('/'):
                directory += '/'
            
            response = self.client.list_objects_v2(
                Bucket=self.bucket,
                Prefix=directory,
                Delimiter='/'
            )
            
            if 'Contents' in response:
                return [obj['Key'] for obj in response['Contents']]
            else:
                return []
        except:
            return []
    
    def directories(self, directory: str = "") -> list:
        """List directories"""
        try:
            directory = directory.lstrip('/')
            if directory and not directory.endswith('/'):
                directory += '/'
            
            response = self.client.list_objects_v2(
                Bucket=self.bucket,
                Prefix=directory,
                Delimiter='/'
            )
            
            if 'CommonPrefixes' in response:
                return [prefix['Prefix'].rstrip('/') for prefix in response['CommonPrefixes']]
            else:
                return []
        except:
            return []
    
    def _get_content_type(self, path: str) -> str:
        """Detect content type from file extension"""
        if path.endswith(('.jpg', '.jpeg')):
            return 'image/jpeg'
        elif path.endswith('.png'):
            return 'image/png'
        elif path.endswith('.gif'):
            return 'image/gif'
        elif path.endswith('.pdf'):
            return 'application/pdf'
        elif path.endswith('.txt'):
            return 'text/plain'
        elif path.endswith('.html'):
            return 'text/html'
        elif path.endswith('.css'):
            return 'text/css'
        elif path.endswith('.js'):
            return 'application/javascript'
        else:
            return 'application/octet-stream'

# ================================================================================
# File: vendor/Illuminate/Filesystem/Drivers/SupabaseDriver.py
# ================================================================================
"""
Supabase Storage Driver
For serverless deployments using Supabase Storage
"""


class SupabaseDriver:
    """Supabase Storage driver"""
    
    def __init__(self, config: dict):
        self.url = config.get("url")
        self.key = config.get("key")
        self.bucket = config.get("bucket", "larathon")
        self.visibility = config.get("visibility", "public")
        
        if not self.url or not self.key:
            raise ValueError("Supabase URL and KEY are required")
        
        self.storage_url = f"{self.url}/storage/v1"
        self.headers = {
            "apikey": self.key,
            "Authorization": f"Bearer {self.key}",
        }
        
        # Ensure bucket exists
        self._ensure_bucket()
    
    def _ensure_bucket(self):
        """Ensure bucket exists, create if needed"""
        try:
            # Check if bucket exists
            response = requests.get(
                f"{self.storage_url}/bucket/{self.bucket}",
                headers=self.headers
            )
            
            if response.status_code == 404:
                # Create bucket
                requests.post(
                    f"{self.storage_url}/bucket",
                    headers={**self.headers, "Content-Type": "application/json"},
                    json={
                        "id": self.bucket,
                        "name": self.bucket,
                        "public": self.visibility == "public"
                    }
                )
        except Exception as e:
            print(f"Warning: Could not ensure bucket exists: {e}")
    
    def put(self, path: str, contents: Union[str, bytes, BinaryIO]) -> bool:
        """Store a file in Supabase Storage"""
        try:
            # Convert contents to bytes
            if isinstance(contents, str):
                file_data = contents.encode('utf-8')
                content_type = 'text/plain'
            elif isinstance(contents, bytes):
                file_data = contents
                content_type = 'application/octet-stream'
            else:  # File-like object
                file_data = contents.read()
                if isinstance(file_data, str):
                    file_data = file_data.encode('utf-8')
                content_type = 'application/octet-stream'
            
            # Detect content type from extension
            if path.endswith(('.jpg', '.jpeg')):
                content_type = 'image/jpeg'
            elif path.endswith('.png'):
                content_type = 'image/png'
            elif path.endswith('.gif'):
                content_type = 'image/gif'
            elif path.endswith('.pdf'):
                content_type = 'application/pdf'
            
            # Remove leading slash
            path = path.lstrip('/')
            
            # Upload file
            response = requests.post(
                f"{self.storage_url}/object/{self.bucket}/{path}",
                headers={
                    **self.headers,
                    "Content-Type": content_type,
                },
                data=file_data
            )
            
            return response.status_code in [200, 201]
            
        except Exception as e:
            print(f"Error uploading to Supabase: {e}")
            return False
    
    def get(self, path: str) -> bytes:
        """Get file contents from Supabase Storage"""
        path = path.lstrip('/')
        
        response = requests.get(
            f"{self.storage_url}/object/{self.bucket}/{path}",
            headers=self.headers
        )
        
        if response.status_code == 200:
            return response.content
        else:
            raise FileNotFoundError(f"File not found: {path}")
    
    def exists(self, path: str) -> bool:
        """Check if file exists"""
        try:
            path = path.lstrip('/')
            response = requests.head(
                f"{self.storage_url}/object/{self.bucket}/{path}",
                headers=self.headers
            )
            return response.status_code == 200
        except:
            return False
    
    def delete(self, path: str) -> bool:
        """Delete a file"""
        try:
            path = path.lstrip('/')
            response = requests.delete(
                f"{self.storage_url}/object/{self.bucket}/{path}",
                headers=self.headers
            )
            return response.status_code in [200, 204]
        except Exception as e:
            print(f"Error deleting file: {e}")
            return False
    
    def url(self, path: str) -> str:
        """Get public URL for file"""
        path = path.lstrip('/')
        
        if self.visibility == "public":
            # Public URL
            return f"{self.storage_url}/object/public/{self.bucket}/{path}"
        else:
            # Signed URL (valid for 1 hour)
            return self._get_signed_url(path, 3600)
    
    def _get_signed_url(self, path: str, expires_in: int = 3600) -> str:
        """Generate signed URL for private files"""
        try:
            response = requests.post(
                f"{self.storage_url}/object/sign/{self.bucket}/{path}",
                headers={**self.headers, "Content-Type": "application/json"},
                json={"expiresIn": expires_in}
            )
            
            if response.status_code == 200:
                data = response.json()
                return f"{self.url}{data['signedURL']}"
            else:
                # Fallback to regular URL
                return f"{self.storage_url}/object/{self.bucket}/{path}"
        except:
            return f"{self.storage_url}/object/{self.bucket}/{path}"
    
    def path(self, path: str) -> str:
        """Get 'path' (actually just returns URL for Supabase)"""
        return self.url(path)
    
    def files(self, directory: str = "") -> list:
        """List files in directory"""
        try:
            directory = directory.lstrip('/')
            
            response = requests.post(
                f"{self.storage_url}/object/list/{self.bucket}",
                headers={**self.headers, "Content-Type": "application/json"},
                json={
                    "prefix": directory,
                    "limit": 100,
                    "offset": 0
                }
            )
            
            if response.status_code == 200:
                items = response.json()
                # Filter only files (not folders)
                return [item['name'] for item in items if item.get('metadata')]
            else:
                return []
        except:
            return []
    
    def directories(self, directory: str = "") -> list:
        """List directories"""
        try:
            directory = directory.lstrip('/')
            
            response = requests.post(
                f"{self.storage_url}/object/list/{self.bucket}",
                headers={**self.headers, "Content-Type": "application/json"},
                json={
                    "prefix": directory,
                    "limit": 100,
                    "offset": 0
                }
            )
            
            if response.status_code == 200:
                items = response.json()
                # Filter only folders
                return [item['name'] for item in items if not item.get('metadata')]
            else:
                return []
        except:
            return []

# ================================================================================
# File: vendor/Illuminate/Filesystem/Drivers/__init__.py
# ================================================================================
# Filesystem Drivers

# ================================================================================
# File: vendor/Illuminate/Filesystem/Storage.py
# ================================================================================
"""
Storage Facade
Laravel-style storage facade for file operations
"""


class StorageManager:
    """Storage Manager - manages multiple storage disks"""
    
    def __init__(self):
        self.disks = {}
        self.default_disk = None
        self._drivers = {}
        
    def configure(self, config: dict):
        """Configure storage from config dict"""
        
        self.default_disk = filesystems.default
        self.disk_configs = filesystems.disks
        
    def disk(self, name: Optional[str] = None):
        """Get a disk instance"""
        disk_name = name or self.default_disk
        
        if disk_name not in self.disks:
            self.disks[disk_name] = self._create_driver(disk_name)
            
        return self.disks[disk_name]
    
    def _create_driver(self, disk_name: str):
        """Create driver instance for disk"""
        
        if disk_name not in filesystems.disks:
            raise ValueError(f"Disk '{disk_name}' is not configured")
        
        config = filesystems.disks[disk_name]
        driver_type = config.get("driver")
        
        if driver_type == "local":
            return LocalDriver(config)
        elif driver_type == "supabase":
            return SupabaseDriver(config)
        elif driver_type == "s3":
            return S3Driver(config)
        else:
            raise ValueError(f"Unknown driver type: {driver_type}")


class StorageFacade:
    """Storage Facade - provides static-like interface"""
    
    _manager = None
    
    @classmethod
    def _get_manager(cls):
        if cls._manager is None:
            cls._manager = StorageManager()
            cls._manager.configure({})
        return cls._manager
    
    @classmethod
    def disk(cls, name: Optional[str] = None):
        """Get a disk instance"""
        return cls._get_manager().disk(name)
    
    @classmethod
    def put(cls, path: str, contents, disk: Optional[str] = None) -> bool:
        """Store a file"""
        return cls.disk(disk).put(path, contents)
    
    @classmethod
    def get(cls, path: str, disk: Optional[str] = None):
        """Get file contents"""
        return cls.disk(disk).get(path)
    
    @classmethod
    def exists(cls, path: str, disk: Optional[str] = None) -> bool:
        """Check if file exists"""
        return cls.disk(disk).exists(path)
    
    @classmethod
    def delete(cls, path: str, disk: Optional[str] = None) -> bool:
        """Delete a file"""
        return cls.disk(disk).delete(path)
    
    @classmethod
    def url(cls, path: str, disk: Optional[str] = None) -> str:
        """Get public URL for a file"""
        return cls.disk(disk).url(path)
    
    @classmethod
    def path(cls, path: str, disk: Optional[str] = None) -> str:
        """Get full path for a file"""
        return cls.disk(disk).path(path)
    
    @classmethod
    def files(cls, directory: str = "", disk: Optional[str] = None) -> list:
        """List files in directory"""
        return cls.disk(disk).files(directory)
    
    @classmethod
    def directories(cls, directory: str = "", disk: Optional[str] = None) -> list:
        """List directories"""
        return cls.disk(disk).directories(directory)


# Singleton instance
Storage = StorageFacade

# ================================================================================
# File: vendor/Illuminate/Filesystem/__init__.py
# ================================================================================
# Filesystem module

# ================================================================================
# File: vendor/Illuminate/Routing/ImprovedRouter.py
# ================================================================================
"""
Improved Router with Laravel-style features
- Middleware support
- Route groups
- Named routes
- Prefix support
"""


class ImprovedRoute:
    """
    Improved Route class with Laravel-style features
    
    Usage:
        # Basic routes
        Route.get('/posts', PostController, 'index')
        
        # With middleware
        Route.get('/dashboard', DashboardController, 'index').middleware(['auth'])
        
        # Named routes
        Route.get('/posts/{id}', PostController, 'show').name('posts.show')
        
        # Route groups
        Route.prefix('admin').middleware(['auth', 'admin']).group(lambda:
            Route.get('/users', UserController, 'index').name('users.index')
            Route.get('/posts', PostController, 'index').name('posts.index')
        )
        
        # Nested groups
        Route.prefix('api').group(lambda:
            Route.prefix('v1').group(lambda:
                Route.get('/users', ApiUserController, 'index')
            )
        )
    """
    
    router = APIRouter()
    _current_group = None
    _named_routes = {}
    _middleware_stack = {}
    
    @classmethod
    def get(cls, path: str, controller, action: str):
        """Register GET route"""
        pending = PendingRoute('GET', path, controller, action, cls)
        pending.register()
        return pending
    
    @classmethod
    def post(cls, path: str, controller, action: str):
        """Register POST route"""
        pending = PendingRoute('POST', path, controller, action, cls)
        pending.register()
        return pending
    
    @classmethod
    def put(cls, path: str, controller, action: str):
        """Register PUT route"""
        pending = PendingRoute('PUT', path, controller, action, cls)
        pending.register()
        return pending
    
    @classmethod
    def delete(cls, path: str, controller, action: str):
        """Register DELETE route"""
        pending = PendingRoute('DELETE', path, controller, action, cls)
        pending.register()
        return pending
    
    @classmethod
    def patch(cls, path: str, controller, action: str):
        """Register PATCH route"""
        pending = PendingRoute('PATCH', path, controller, action, cls)
        pending.register()
        return pending
    
    @classmethod
    def prefix(cls, prefix: str):
        """Start a new route group with prefix"""
        group = RouteGroup()
        return group.prefix(prefix)
    
    @classmethod
    def middleware(cls, middleware: List[str]):
        """Start a new route group with middleware"""
        group = RouteGroup()
        return group.middleware(middleware)
    
    @classmethod
    def name(cls, name: str):
        """Start a new route group with name prefix"""
        group = RouteGroup()
        return group.name(name)
    
    @classmethod
    def group(cls, attributes: Dict, callback: Callable):
        """Create route group with attributes dict"""
        group = RouteGroup()
        
        if 'prefix' in attributes:
            group.prefix(attributes['prefix'])
        if 'middleware' in attributes:
            group.middleware(attributes['middleware'])
        if 'name' in attributes:
            group.name(attributes['name'])
        if 'namespace' in attributes:
            group.namespace(attributes['namespace'])
        
        return group.group(callback)
    
    @classmethod
    def resource(cls, name: str, controller):
        """Register resource routes (CRUD)"""
        group = cls._current_group or {}
        prefix = group.get('prefix', '')
        name_prefix = group.get('name', '')
        middleware = group.get('middleware', [])
        
        # Build full path
        base_path = f"/{prefix}/{name}".replace('//', '/').rstrip('/')
        
        # Register all resource routes
        routes = [
            ('GET', f"{base_path}", 'index', f"{name_prefix}{name}.index"),
            ('GET', f"{base_path}/create", 'create', f"{name_prefix}{name}.create"),
            ('POST', f"{base_path}", 'store', f"{name_prefix}{name}.store"),
            ('GET', f"{base_path}/{{id}}", 'show', f"{name_prefix}{name}.show"),
            ('GET', f"{base_path}/{{id}}/edit", 'edit', f"{name_prefix}{name}.edit"),
            ('PUT', f"{base_path}/{{id}}", 'update', f"{name_prefix}{name}.update"),
            ('DELETE', f"{base_path}/{{id}}", 'destroy', f"{name_prefix}{name}.destroy"),
        ]
        
        for method, path, action, route_name in routes:
            cls._register_route(method, path, controller, action, middleware, route_name)
    
    @classmethod
    def _register_route(cls, method: str, path: str, controller, action: str, 
                       middleware: List[str] = None, name: str = None):
        """Internal method to register route with FastAPI"""
        # Store middleware for this route
        if middleware:
            cls._middleware_stack[path] = middleware
        
        # Store named route
        if name:
            cls._named_routes[name] = path
        
        # Get controller instance and method
        controller_instance = controller() if callable(controller) else controller
        handler = getattr(controller_instance, action)
        
        # Inspect handler signature to check if it needs form data injection
        handler_sig = signature(handler)
        needs_form_injection = any(
            param.annotation == Form or 
            (hasattr(param.annotation, '__origin__') and param.annotation.__origin__ == type(Form))
            for param in handler_sig.parameters.values()
            if param.name != 'request' and param.name != 'self'
        )
        
        # Create wrapper function with proper signature
        if middleware:
            # With middleware - wrap the handler
            async def route_handler(request: Request):
                """Wrapper that executes middleware before controller"""
                
                # DEBUG: Check request details
                print(f"DEBUG Router: Method={request.method}, Path={request.url.path}")
                print(f"DEBUG Router: Content-Type={request.headers.get('content-type')}")
                
                # Execute middleware chain
                for middleware_name in middleware:
                    # Check auth middleware
                    if middleware_name == 'auth':
                        if not getattr(request.state, 'authenticated', False):
                            if request.url.path.startswith('/api/'):
                                return JSONResponse(
                                    {'error': 'Unauthorized', 'message': 'Authentication required'},
                                    status_code=401
                                )
                            return RedirectResponse(url=f'/login?redirect={request.url.path}', status_code=302)
                    
                    # Check admin middleware
                    elif middleware_name == 'admin':
                        user_role = request.state.user.get('role', 'user') if hasattr(request.state, 'user') else 'user'
                        if user_role != 'admin':
                            return JSONResponse(
                                {'error': 'Forbidden', 'message': 'Requires admin role'},
                                status_code=403
                            )
                
                # Get path parameters from request
                path_params = request.path_params
                
                # Call the actual controller method
                if inspect.iscoroutinefunction(handler):
                    return await handler(request, **path_params)
                else:
                    return handler(request, **path_params)
        else:
            # Without middleware - use handler directly
            async def route_handler(request: Request):
                """Direct handler without middleware"""
                # DEBUG
                print(f"DEBUG Router (no middleware): Method={request.method}, Path={request.url.path}")
                print(f"DEBUG Router: Content-Type={request.headers.get('content-type')}")
                
                path_params = request.path_params
                
                if inspect.iscoroutinefunction(handler):
                    return await handler(request, **path_params)
                else:
                    return handler(request, **path_params)
        
        # Register with FastAPI router based on method
        methods_map = {
            'GET': cls.router.get,
            'POST': cls.router.post,
            'PUT': cls.router.put,
            'DELETE': cls.router.delete,
            'PATCH': cls.router.patch,
        }
        
        route_decorator = methods_map.get(method.upper())
        if route_decorator:
            route_decorator(path)(route_handler)
    
    @classmethod
    def get_named_route(cls, name: str, params: Dict = None) -> str:
        """Get URL for named route"""
        if name not in cls._named_routes:
            raise ValueError(f"Route '{name}' not found")
        
        path = cls._named_routes[name]
        
        # Replace parameters
        if params:
            for key, value in params.items():
                path = path.replace(f"{{{key}}}", str(value))
        
        return path
    
    @classmethod
    def has_middleware(cls, path: str, middleware_name: str) -> bool:
        """Check if route has specific middleware"""
        route_middleware = cls._middleware_stack.get(path, [])
        return middleware_name in route_middleware


# Create global instance
Route = ImprovedRoute

# ================================================================================
# File: vendor/Illuminate/Routing/RouteGroup.py
# ================================================================================
"""
Route Group - Laravel-style route grouping
"""


class RouteGroup:
    """
    Route group for applying common attributes to multiple routes
    
    Usage:
        Route.prefix('admin').middleware(['auth']).group(lambda:
            Route.get('/users', UserController, 'index')
            Route.get('/posts', PostController, 'index')
        )
    """
    
    def __init__(self):
        self.attributes = {
            'prefix': '',
            'name': '',
            'middleware': [],
            'namespace': ''
        }
    
    def prefix(self, prefix: str):
        """Set URL prefix for all routes in group"""
        self.attributes['prefix'] = prefix.strip('/')
        return self
    
    def name(self, name: str):
        """Set name prefix for all routes in group"""
        self.attributes['name'] = name
        return self
    
    def middleware(self, middleware: List[str]):
        """Set middleware for all routes in group"""
        if isinstance(middleware, str):
            middleware = [middleware]
        self.attributes['middleware'] = middleware
        return self
    
    def namespace(self, namespace: str):
        """Set controller namespace for all routes in group"""
        self.attributes['namespace'] = namespace
        return self
    
    def group(self, callback: Callable):
        """Execute the group callback with current attributes"""
        # Store current group context
        previous_group = ImprovedRoute._current_group
        
        # Merge with parent group if exists
        if previous_group:
            merged_attributes = {
                'prefix': f"{previous_group['prefix']}/{self.attributes['prefix']}".strip('/'),
                'name': f"{previous_group['name']}{self.attributes['name']}",
                'middleware': previous_group['middleware'] + self.attributes['middleware'],
                'namespace': self.attributes['namespace'] or previous_group['namespace']
            }
            ImprovedRoute._current_group = merged_attributes
        else:
            ImprovedRoute._current_group = self.attributes.copy()
        
        # Execute callback to register routes
        callback()
        
        # Restore previous group context
        ImprovedRoute._current_group = previous_group
        
        return self


class PendingRoute:
    """
    Pending route that can have middleware and name applied
    
    Usage:
        Route.get('/dashboard', DashboardController, 'index')
             .middleware(['auth'])
             .name('dashboard')
    """
    
    def __init__(self, method: str, path: str, controller, action: str, router):
        self.method = method
        self.path = path
        self.controller = controller
        self.action = action
        self.router = router
        self.route_middleware = []
        self.route_name = None
    
    def middleware(self, middleware: List[str]):
        """Add middleware to this specific route"""
        if isinstance(middleware, str):
            middleware = [middleware]
        self.route_middleware = middleware
        return self
    
    def name(self, name: str):
        """Set name for this route"""
        self.route_name = name
        return self
    
    def register(self):
        """Register the route with all attributes"""
        # Get current group attributes
        group = ImprovedRoute._current_group or {}
        
        # Merge path with group prefix
        prefix = group.get('prefix', '').strip('/')
        path = self.path.strip('/')
        
        if prefix and path:
            full_path = f"/{prefix}/{path}"
        elif prefix:
            full_path = f"/{prefix}"
        elif path:
            full_path = f"/{path}"
        else:
            full_path = '/'
        
        # Merge middleware
        all_middleware = group.get('middleware', []) + self.route_middleware
        
        # Merge name
        full_name = f"{group.get('name', '')}{self.route_name or ''}"
        
        # Register the route with router
        self.router._register_route(
            self.method,
            full_path,
            self.controller,
            self.action,
            middleware=all_middleware,
            name=full_name
        )

# ================================================================================
# File: vendor/Illuminate/Routing/Router.py
# ================================================================================
class Router:
    routes = []
    router = APIRouter()

    @classmethod
    def add(cls, method, path, controller=None, action=None):
        # regex untuk match route <id>
        pattern = "^" + re.sub(r"<(\w+)>", r"(?P<\1>[^/]+)", path) + "$"
        fastapi_path = path.replace("<", "{").replace(">", "}")

        cls.routes.append({
            "method": method.upper(),
            "path": path,
            "pattern": re.compile(pattern),
            "controller": controller,
            "action": action
        })

        async def endpoint(request: Request):
            path_params = request.path_params

            # --- Method Spoofing (Laravel style) ---
            if request.method == "POST":
                try:
                    form = await request.form()
                    if "_method" in form:
                        method_override = form["_method"].upper()

                        action_map = {
                            "PUT": "update",
                            "DELETE": "destroy"
                        }

                        if method_override in action_map:
                            # âœ… simpan form ke request supaya bisa dipakai nanti
                            request.state._form = form

                            # ðŸš€ tentukan handler langsung
                            instance = controller()
                            handler = getattr(instance, action_map[method_override])
                            if inspect.iscoroutinefunction(handler):
                                return await handler(request, **path_params)
                            return handler(request, **path_params)
                except Exception as e:
                    print("âš ï¸ Spoofing error:", e)

            # --- CASE 1: closure langsung
            if callable(controller) and action is None:
                sig = inspect.signature(controller)
                args = {}
                for name, param in sig.parameters.items():
                    if name in path_params:
                        args[name] = path_params[name]
                    elif name == "request":
                        args[name] = request

                if inspect.iscoroutinefunction(controller):
                    return await controller(**args)
                return controller(**args)

            # --- CASE 2: controller class
            instance = controller()
            handler = getattr(instance, action)
            sig = inspect.signature(handler)
            args = {}
            for name, param in sig.parameters.items():
                if name in path_params:
                    args[name] = path_params[name]
                elif name == "request":
                    args[name] = request

            if inspect.iscoroutinefunction(handler):
                return await handler(**args)
            return handler(**args)

        # register ke FastAPI
        cls.router.add_api_route(
            fastapi_path,
            endpoint,
            methods=[method.upper()]
        )

    # Shortcut methods
    @classmethod
    def get(cls, path, controller=None, action=None):
        cls.add("GET", path, controller, action)

    @classmethod
    def post(cls, path, controller=None, action=None):
        cls.add("POST", path, controller, action)

    @classmethod
    def put(cls, path, controller=None, action=None):
        cls.add("PUT", path, controller, action)

    @classmethod
    def delete(cls, path, controller=None, action=None):
        cls.add("DELETE", path, controller, action)

    # resource style
    @classmethod
    def resource(cls, name, controller):
        base = f"/{name}"
        cls.get(base, controller, "index")
        cls.get(f"{base}/create", controller, "create")
        cls.post(base, controller, "store")
        cls.get(f"{base}/<id>", controller, "show")
        cls.get(f"{base}/<id>/edit", controller, "edit")
        cls.put(f"{base}/<id>", controller, "update")
        cls.delete(f"{base}/<id>", controller, "destroy")

    @classmethod
    def list_routes(cls):
        return cls.routes

Route = Router

# ================================================================================
# File: vendor/Illuminate/Support/Env.py
# ================================================================================
# tentukan root project (di mana artisan.py berada)
BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), "../../.."))
ENV_PATH = os.path.join(BASE_DIR, ".env")

# load file .env sekali
if os.path.exists(ENV_PATH):
    load_dotenv(ENV_PATH)

class Env:
    @staticmethod
    def get(key: str, default=None):
        return os.getenv(key, default)

# alias mirip Laravel
env = Env.get

# ================================================================================
# File: vendor/Illuminate/Support/Facades/App.py
# ================================================================================
class App:
    _bindings = {}

    @classmethod
    def bind(cls, key, instance):
        cls._bindings[key] = instance

    @classmethod
    def make(cls, key):
        return cls._bindings[key]

# ================================================================================
# File: vendor/Illuminate/Support/Facades/Facade.py
# ================================================================================
class FacadeMeta(type):
    def __getattr__(cls, name):
        root = cls.get_facade_root()
        if root is None:
            raise AttributeError(f"Facade root for '{cls.__name__}' is not set")
        return getattr(root, name)

    def __call__(cls, *args, **kwargs):
        root = cls.get_facade_root()
        if root is None:
            raise AttributeError(f"Facade root for '{cls.__name__}' is not set")
        return root(*args, **kwargs)


class Facade(metaclass=FacadeMeta):
    _resolved = {}

    @classmethod
    def get_facade_accessor(cls):
        raise NotImplementedError("Facade must implement get_facade_accessor")

    @classmethod
    def get_facade_root(cls):
        accessor = cls.get_facade_accessor()
        return cls._resolved.get(accessor)

    @classmethod
    def swap(cls, instance):
        accessor = cls.get_facade_accessor()
        cls._resolved[accessor] = instance

# ================================================================================
# File: vendor/Illuminate/Support/Facades/Response.py
# ================================================================================
# vendor/Illuminate/Support/Facades/Response.py

class Response:
    @staticmethod
    def json(data: dict, status: int = 200):
        return JSONResponse(content=data, status_code=status)

# helper global
def response(data: dict, status: int = 200):
    return Response.json(data, status)

# ================================================================================
# File: vendor/Illuminate/Support/Facades/Route.py
# ================================================================================
# vendor/Illuminate/Support/Facades/Route.py

class Route(Facade):
    @classmethod
    def get_facade_accessor(cls):
        return "router"

# ================================================================================
# File: vendor/Illuminate/Support/Facades/View.py
# ================================================================================
# vendor/Illuminate/Support/Facades/View.py

class View:
    @staticmethod
    def make(template: str, context: dict = {}):
        return BaseView.make(template, context)

def view(template: str, context: dict = {}):
    return View.make(template, context)

# ================================================================================
# File: vendor/Illuminate/Support/Helpers/storage.py
# ================================================================================
"""
Storage Helper Functions
Convenient functions for file storage operations
"""


def storage_path(path: str = "") -> str:
    """Get path to storage directory"""
    base = os.path.join(os.getcwd(), "storage", "app")
    if path:
        return os.path.join(base, path.lstrip('/'))
    return base


def public_path(path: str = "") -> str:
    """Get path to public directory"""
    base = os.path.join(os.getcwd(), "public")
    if path:
        return os.path.join(base, path.lstrip('/'))
    return base


def asset(path: str) -> str:
    """Generate URL for asset"""
    return f"/static/{path.lstrip('/')}"


def storage_url(path: str, disk: str = None) -> str:
    """Generate public URL for stored file"""
    return Storage.url(path, disk)


def upload_file(file, directory: str = "", disk: str = None, name: str = None) -> str:
    """
    Upload file and return path
    
    Args:
        file: File object (from request.files) - UploadFile from Starlette
        directory: Directory to store in
        disk: Storage disk to use
        name: Custom filename (optional)
    
    Returns:
        Stored file path
    """
    
    # Check if file has filename
    if not hasattr(file, 'filename') or not file.filename:
        raise ValueError("Invalid file object - no filename")
    
    # Generate filename
    if name:
        filename = name
    else:
        # Use original filename
        filename = file.filename
        
        # Add timestamp to avoid collisions
        name, ext = os.path.splitext(filename)
        timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
        filename = f"{name}_{timestamp}{ext}"
    
    # Build path
    if directory:
        path = f"{directory.rstrip('/')}/{filename}"
    else:
        path = filename
    
    # Read file content
    # For UploadFile (Starlette), we need to read the content
    if hasattr(file, 'read'):
        # Check if it's async
        if asyncio.iscoroutinefunction(file.read):
            # This is async - need to handle it differently
            # For now, we'll use file.file which is sync
            if hasattr(file, 'file'):
                file_content = file.file.read()
            else:
                raise ValueError("Cannot read file content - async context required")
        else:
            file_content = file.read()
    else:
        raise ValueError("File object does not have read() method")
    
    # Store file
    Storage.put(path, file_content, disk)
    
    return path


def delete_file(path: str, disk: str = None) -> bool:
    """Delete a stored file"""
    return Storage.delete(path, disk)


def file_exists(path: str, disk: str = None) -> bool:
    """Check if file exists in storage"""
    return Storage.exists(path, disk)


def get_file_url(path: str, disk: str = None) -> str:
    """Get public URL for file"""
    return Storage.url(path, disk)

# ================================================================================
# File: vendor/Illuminate/Support/config_loader.py
# ================================================================================
BASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
ENV_PATH = os.path.join(BASE_DIR, ".env")

load_dotenv(dotenv_path=ENV_PATH)

def load_config():
    return {
        "APP_NAME": os.getenv("APP_NAME", "FastAPI App"),
        "APP_ENV": os.getenv("APP_ENV", "local"),
        "APP_DEBUG": os.getenv("APP_DEBUG", "false").lower() == "true",
        "APP_PORT": os.getenv("APP_PORT", "8000"),

        "DB_CONNECTION": os.getenv("DB_CONNECTION", "sqlite"),
        "DB_HOST": os.getenv("DB_HOST", "127.0.0.1"),
        "DB_PORT": os.getenv("DB_PORT", "3306"),
        "DB_DATABASE": os.getenv("DB_DATABASE", "database.sqlite"),
        "DB_USERNAME": os.getenv("DB_USERNAME", "root"),
        "DB_PASSWORD": os.getenv("DB_PASSWORD", ""),
    }

# ================================================================================
# File: vendor/Illuminate/View/View.py
# ================================================================================
# vendor/Illuminate/View/View.py

# Try multiple possible template locations for Vercel compatibility
_current_file_dir = os.path.dirname(os.path.abspath(__file__))
_possible_paths = [
    os.path.join(_current_file_dir, "resources", "views"),     # local: vendor/Illuminate/View/resources/views
    os.path.join(os.getcwd(), "api", "resources", "views"),    # Vercel: /var/task/api/resources/views
    os.path.join(os.getcwd(), "resources", "views"),           # local: /project/resources/views
    "api/resources/views",                                      # relative with api prefix
    "resources/views",                                          # relative fallback
]

VIEWS_DIR = None
for path in _possible_paths:
    if os.path.exists(path):
        VIEWS_DIR = path
        break

if VIEWS_DIR is None:
    # Last resort: try api/resources/views (Vercel serverless)
    VIEWS_DIR = "api/resources/views"

templates = Jinja2Templates(directory=VIEWS_DIR)

class View:
    @staticmethod
    def make(template: str, context: dict = None):
        # default kosong
        context = context or {}
        if "request" not in context:
            raise ValueError('View.make() requires "request" in context')
        return templates.TemplateResponse(template.replace(".", "/") + ".html", context)

# ================================================================================
# File: vendor/Illuminate/View/ViewFactory.py
# ================================================================================
class ViewFactory:
    def __init__(self):
        # atur folder templates (resources/views)
        views_path = os.path.join(os.getcwd(), "resources", "views")
        self.env = Environment(
            loader=FileSystemLoader(views_path),
            autoescape=select_autoescape(['html', 'xml'])
        )

    def make(self, template, context=None):
        context = context or {}
        # laravel style: todos/index â†’ todos/index.html
        template_path = template + ".html"
        tpl = self.env.get_template(template_path)
        return tpl.render(**context)

# ================================================================================
# File: vendor/framework/config_loader.py
# ================================================================================
BASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
CONFIG_DIR = os.path.join(BASE_DIR, "config")

class Config:
    _cache = {}

    @classmethod
    def load(cls, name):
        if name in cls._cache:
            return cls._cache[name]

        file_path = os.path.join(CONFIG_DIR, f"{name}.py")
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"Config file not found: {name}.py")

        spec = importlib.util.spec_from_file_location(name, file_path)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)

        cls._cache[name] = getattr(module, "config", {})
        return cls._cache[name]

    @classmethod
    def get(cls, key, default=None):
        """
        key: "app.name" atau "database.default"
        """
        parts = key.split(".")
        if len(parts) < 2:
            raise ValueError("Config key must be in 'file.key' format")

        file, subkey = parts[0], ".".join(parts[1:])
        config = cls.load(file)

        value = config
        for part in subkey.split("."):
            value = value.get(part) if isinstance(value, dict) else None
        return value if value is not None else default

# ================================================================================
# File: vendor/framework/provider_manager.py
# ================================================================================
class ProviderManager:
    def __init__(self, providers):
        self.providers = providers
        self.instances = []

    def boot(self, app):
        for provider in self.providers:
            module_path, class_name = provider.rsplit(".", 1)
            module = importlib.import_module(module_path)
            cls = getattr(module, class_name)
            instance = cls()
            if hasattr(instance, "register"):
                instance.register(app)
            if hasattr(instance, "boot"):
                instance.boot(app)
            self.instances.append(instance)

# ================================================================================
# File: database/session.py
# ================================================================================
# database/session.py

engine = get_engine()
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# ================================================================================
# File: app/Http/Controllers/Controller.py
# ================================================================================
class Controller:
    def view(self, template: str, request, context: dict = None):
        context = context or {}
        context["request"] = request
        return View.make(template, context)

    def redirect(self, url: str, status_code: int = 303):
        """Laravel-style redirect helper"""
        return RedirectResponse(url=url, status_code=status_code)

    async def request(self, request):
        """Auto detect request JSON/Form dan ignore _method."""
        content_type = request.headers.get("content-type", "")
        print("ðŸ“Œ Content-Type:", content_type)   # ðŸ‘ˆ debug
        print("ðŸ“Œ Request method:", request.method)

        if "application/json" in content_type:
            data = await request.json()
            print("ðŸ“¥ JSON DATA:", data)   # ðŸ‘ˆ debug
            return data

        elif "application/x-www-form-urlencoded" in content_type or "multipart/form-data" in content_type:
            raw = await request.body()
            print("ðŸ“¥ RAW BODY:", raw.decode())
            form = await request.form()
            print("ðŸ“¥ RAW FORM:", form)
            data = {k: v for k, v in form.items() if k != "_method"}
            print("ðŸ“¥ CLEANED FORM DATA:", data)
            return data

        print("âš ï¸ Unknown body, returning empty dict")
        return {}

# ================================================================================
# File: app/Http/Middleware/AuthMiddleware.py
# ================================================================================
"""
Authentication Middleware
"""


class AuthMiddleware(BaseHTTPMiddleware):
    """
    Authentication middleware
    Protects routes that require authentication
    """
    
    async def dispatch(self, request, call_next):
        # Get token from cookie or header
        token = request.cookies.get('auth_token')
        
        if not token:
            # Try Authorization header
            auth_header = request.headers.get('Authorization')
            token = JWT.extract_from_header(auth_header)
        
        # Decode token
        payload = JWT.decode(token) if token else None
        
        # Attach user info to request state
        if payload:
            request.state.user = payload
            request.state.authenticated = True
        else:
            request.state.user = None
            request.state.authenticated = False
        
        response = await call_next(request)
        return response


def require_auth(func):
    """
    Decorator to require authentication for a route
    Usage: @require_auth
    """
    async def wrapper(self, request, *args, **kwargs):
        if not getattr(request.state, 'authenticated', False):
            # Check if it's an API request
            if request.url.path.startswith('/api/'):
                return JSONResponse(
                    {'error': 'Unauthorized', 'message': 'Authentication required'},
                    status_code=401
                )
            # Redirect to login for web requests
            return RedirectResponse(url=f'/login?redirect={request.url.path}', status_code=302)
        
        return await func(self, request, *args, **kwargs)
    
    return wrapper


def require_role(role: str):
    """
    Decorator to require specific role
    Usage: @require_role('admin')
    """
    def decorator(func):
        async def wrapper(self, request, *args, **kwargs):
            if not getattr(request.state, 'authenticated', False):
                if request.url.path.startswith('/api/'):
                    return JSONResponse(
                        {'error': 'Unauthorized', 'message': 'Authentication required'},
                        status_code=401
                    )
                return RedirectResponse(url=f'/login?redirect={request.url.path}', status_code=302)
            
            user_role = request.state.user.get('role', 'user')
            if user_role != role:
                if request.url.path.startswith('/api/'):
                    return JSONResponse(
                        {'error': 'Forbidden', 'message': f'Requires {role} role'},
                        status_code=403
                    )
                return JSONResponse(
                    {'error': 'Access denied', 'message': f'Requires {role} role'},
                    status_code=403
                )
            
            return await func(self, request, *args, **kwargs)
        
        return wrapper
    return decorator


async def get_current_user(request):
    """Helper function to get current authenticated user"""
    if not getattr(request.state, 'authenticated', False):
        return None
    
    user_id = request.state.user.get('user_id')
    if not user_id:
        return None
    
    return await User.find(user_id)

# ================================================================================
# File: app/Http/Middleware/MethodOverrideMiddleware.py
# ================================================================================
class MethodOverrideMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        if request.method == "POST":
            try:
                # Read form data and CACHE it in request.state
                form = await request.form()
                
                # Cache form data so controller can access it
                request.state._cached_form = form
                
                # hanya override jika ada _method dan nilainya valid
                if "_method" in form:
                    method_override = form["_method"].upper()
                    if method_override in ("PUT", "DELETE", "PATCH"):
                        request.scope["method"] = method_override
            except Exception:
                pass
        return await call_next(request)

# ================================================================================
# File: app/Http/Controllers/AuthController.py
# ================================================================================
"""
Authentication Controller
"""


class AuthController(Controller):
    """Handle user authentication"""
    
    def show_login(self, request):
        """Show login form"""
        if getattr(request.state, 'authenticated', False):
            return RedirectResponse(url='/dashboard', status_code=302)
        
        redirect_to = request.query_params.get('redirect', '/dashboard')
        return self.view('auth.login', request, {'redirect_to': redirect_to})
    
    def show_register(self, request):
        """Show registration form"""
        if getattr(request.state, 'authenticated', False):
            return RedirectResponse(url='/dashboard', status_code=302)
        
        return self.view('auth.register', request)
    
    async def register(self, request):
        """Handle user registration"""
        try:
            form = await request.form()
            name = form.get('name', '').strip()
            email = form.get('email', '').strip().lower()
            password = form.get('password', '')
            password_confirm = form.get('password_confirm', '')
            
            # Validation
            errors = []
            if not name or len(name) < 2:
                errors.append('Name must be at least 2 characters')
            if not email or '@' not in email:
                errors.append('Valid email is required')
            if not password or len(password) < 6:
                errors.append('Password must be at least 6 characters')
            if password != password_confirm:
                errors.append('Passwords do not match')
            
            # Check if email exists
            existing_user = await User.find_by_email(email)
            if existing_user:
                errors.append('Email already registered')
            
            if errors:
                return self.view('auth.register', request, {
                    'errors': errors,
                    'name': name,
                    'email': email
                })
            
            # Create user
            user = await User.create_user(name, email, password)
            
            # Generate token
            token = JWT.generate(user.id, user.email, user.role)
            
            # Set cookie and redirect
            response = RedirectResponse(url='/dashboard', status_code=302)
            response.set_cookie(
                key='auth_token',
                value=token,
                httponly=True,
                max_age=86400,  # 24 hours
                samesite='lax'
            )
            return response
            
        except Exception as e:
            return self.view('auth.register', request, {
                'errors': [f'Registration failed: {str(e)}']
            })
    
    async def login(self, request):
        """Handle user login"""
        try:
            # Get form data from cache (set by MethodOverrideMiddleware)
            # or read fresh if not cached
            if hasattr(request.state, '_cached_form'):
                form = request.state._cached_form
                print(f"DEBUG: Using cached form data: {dict(form)}")
            else:
                form = await request.form()
                print(f"DEBUG: Form data read fresh: {dict(form)}")
            
            email = form.get('email', '').strip().lower()
            password = form.get('password', '')
            redirect_to = form.get('redirect_to', '/dashboard')
            
            print(f"DEBUG: Email={email}, Password={'*' * len(password) if password else 'EMPTY'}, Redirect={redirect_to}")
            
            # Validation
            if not email or not password:
                return self.view('auth.login', request, {
                    'error': 'Email and password are required',
                    'email': email,
                    'redirect_to': redirect_to
                })
            
            # Find user
            user = await User.find_by_email(email)
            
            if not user or not user.verify_password(password):
                return self.view('auth.login', request, {
                    'error': 'Invalid email or password',
                    'email': email,
                    'redirect_to': redirect_to
                })
            
            if not user.is_active:
                return self.view('auth.login', request, {
                    'error': 'Account is disabled',
                    'email': email,
                    'redirect_to': redirect_to
                })
            
            # Generate token
            token = JWT.generate(user.id, user.email, user.role)
            
            # Set cookie and redirect
            response = RedirectResponse(url=redirect_to, status_code=302)
            response.set_cookie(
                key='auth_token',
                value=token,
                httponly=True,
                max_age=86400,  # 24 hours
                samesite='lax'
            )
            return response
            
        except Exception as e:
            return self.view('auth.login', request, {
                'error': f'Login failed: {str(e)}',
                'redirect_to': redirect_to
            })
    
    def logout(self, request):
        """Handle user logout"""
        response = RedirectResponse(url='/', status_code=302)
        response.delete_cookie('auth_token')
        return response
    
    async def profile(self, request):
        """Show user profile"""
        
        user = await get_current_user(request)
        if not user:
            return RedirectResponse(url='/login', status_code=302)
        
        return self.view('auth.profile', request, {'user': user})

# ================================================================================
# File: app/Http/Controllers/DashboardController.py
# ================================================================================
"""
Dashboard Controller
"""


class DashboardController(Controller):
    """Handle dashboard operations"""
    
    @require_auth
    async def index(self, request):
        """Show dashboard home"""
        try:
            user = await get_current_user(request)
            print(f"DEBUG Dashboard: User = {user}")
            
            if not user:
                print("ERROR: User not found!")
                return self.redirect('/login')
            
            # Get user's posts (handle if table doesn't exist)
            try:
                posts = await Post.where('user_id', user.id).get()
                print(f"DEBUG Dashboard: Found {len(posts)} posts")
            except Exception as e:
                print(f"WARNING: Could not fetch posts: {e}")
                posts = []
            
            # Get stats
            total_posts = len(posts)
            published_posts = len([p for p in posts if hasattr(p, 'status') and p.status == 'published'])
            draft_posts = len([p for p in posts if hasattr(p, 'status') and p.status == 'draft'])
            
            return self.view('dashboard.index', request, {
                'user': user,
                'posts': posts[:5],  # Show last 5 posts
                'stats': {
                    'total_posts': total_posts,
                    'published': published_posts,
                    'drafts': draft_posts
                }
            })
        except Exception as e:
            print(f"ERROR Dashboard: {e}")
            traceback.print_exc()
            return self.view('dashboard.index', request, {
                'user': {'name': 'Guest', 'email': 'N/A'},
                'posts': [],
                'stats': {
                    'total_posts': 0,
                    'published': 0,
                    'drafts': 0
                },
                'error': str(e)
            })

# ================================================================================
# File: app/Http/Controllers/PostController.py
# ================================================================================
"""
Post Controller
"""


class PostController(Controller):
    """Handle post/content CRUD operations"""
    
    @require_auth
    async def index(self, request):
        """List all posts for current user"""
        user = await get_current_user(request)
        posts = await Post.by_user(user.id).get()
        
        return self.view('posts.index', request, {
            'user': user,
            'posts': posts
        })
    
    @require_auth
    async def create(self, request):
        """Show create post form"""
        user = await get_current_user(request)
        return self.view('posts.create', request, {'user': user})
    
    @require_auth
    async def store(self, request):
        """Store new post"""
        user = await get_current_user(request)
        
        try:
            form = await request.form()
            title = form.get('title', '').strip()
            content = form.get('content', '').strip()
            excerpt = form.get('excerpt', '').strip()
            status = form.get('status', 'draft')
            featured_image_file = form.get('featured_image')
            
            # Debug logging
            print(f"Form data received - Title: {title}, Status: {status}")
            print(f"Featured image file: {featured_image_file}, Type: {type(featured_image_file)}")
            
            # Validation
            if not title:
                return self.view('posts.create', request, {
                    'user': user,
                    'error': 'Title is required',
                    'title': title,
                    'content': content
                })
            
            # Handle featured image upload
            featured_image_path = None
            if featured_image_file:
                # Check if it's actually a file (not just empty form field)
                if hasattr(featured_image_file, 'filename') and featured_image_file.filename:
                    print(f"Processing image: {featured_image_file.filename}")
                    
                    # Generate unique filename
                    ext = os.path.splitext(featured_image_file.filename)[1]
                    timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
                    filename = f"post_{timestamp}{ext}"
                    path = f"posts/{filename}"
                    
                    # Upload to storage
                    file_content = await featured_image_file.read()
                    
                    if file_content:  # Only upload if not empty
                        Storage.put(path, file_content)
                        featured_image_path = path
                        print(f"Image uploaded to: {path}")
                    else:
                        print("Image file is empty, skipping upload")
                else:
                    print("No filename or empty file field")
            
            # Create post
            post = await Post.create_post(
                user_id=user.id,
                title=title,
                content=content,
                excerpt=excerpt or (content[:200] if content else ''),
                featured_image=featured_image_path,
                status=status
            )
            
            print(f"Post created with ID: {post.id}")
            
            return RedirectResponse(url='/posts', status_code=302)
            
        except Exception as e:
            error_trace = traceback.format_exc()
            print(f"Error creating post: {error_trace}")
            
            return self.view('posts.create', request, {
                'user': user,
                'error': f'Failed to create post: {str(e)}'
            })
    
    @require_auth
    async def show(self, request, post_id: int):
        """Show single post"""
        user = await get_current_user(request)
        post = await Post.find(post_id)
        
        if not post:
            return RedirectResponse(url='/posts', status_code=302)
        
        # Check ownership
        if post.user_id != user.id:
            return RedirectResponse(url='/posts', status_code=302)
        
        return self.view('posts.show', request, {
            'user': user,
            'post': post
        })
    
    @require_auth
    async def edit(self, request, post_id: int):
        """Show edit post form"""
        user = await get_current_user(request)
        post = await Post.find(post_id)
        
        if not post or post.user_id != user.id:
            return RedirectResponse(url='/posts', status_code=302)
        
        return self.view('posts.edit', request, {
            'user': user,
            'post': post
        })
    
    @require_auth
    async def update(self, request, post_id: int):
        """Update existing post"""
        user = await get_current_user(request)
        post = await Post.find(post_id)
        
        if not post or post.user_id != user.id:
            return RedirectResponse(url='/posts', status_code=302)
        
        try:
            form = await request.form()
            title = form.get('title', '').strip()
            content = form.get('content', '').strip()
            excerpt = form.get('excerpt', '').strip()
            status = form.get('status', 'draft')
            featured_image_file = form.get('featured_image')
            
            # Validation
            if not title:
                return self.view('posts.edit', request, {
                    'user': user,
                    'post': post,
                    'error': 'Title is required'
                })
            
            # Handle featured image upload
            if featured_image_file and hasattr(featured_image_file, 'filename') and featured_image_file.filename:
                # Delete old image
                if post.featured_image:
                    try:
                        Storage.delete(post.featured_image)
                    except:
                        pass
                
                # Upload new image
                ext = os.path.splitext(featured_image_file.filename)[1]
                timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
                filename = f"post_{timestamp}{ext}"
                path = f"posts/{filename}"
                
                file_content = await featured_image_file.read()
                Storage.put(path, file_content)
                post.featured_image = path
            
            # Update post
            post.title = title
            post.slug = Post.generate_slug(title)
            post.content = content
            post.excerpt = excerpt or (content[:200] if content else '')
            post.status = status
            
            if status == 'published' and not post.published_at:
                post.published_at = datetime.now()
            
            await post.save()
            
            return RedirectResponse(url='/posts', status_code=302)
            
        except Exception as e:
            return self.view('posts.edit', request, {
                'user': user,
                'post': post,
                'error': f'Failed to update post: {str(e)}'
            })
    
    @require_auth
    async def destroy(self, request, post_id: int):
        """Delete post"""
        user = await get_current_user(request)
        post = await Post.find(post_id)
        
        if not post or post.user_id != user.id:
            return RedirectResponse(url='/posts', status_code=302)
        
        # Delete featured image if exists
        if post.featured_image:
            try:
                Storage.delete(post.featured_image)
            except:
                pass
        
        # Delete post
        await post.delete()
        
        return RedirectResponse(url='/posts', status_code=302)

# ================================================================================
# File: app/Http/Controllers/StorageController.py
# ================================================================================
class StorageController(Controller):
    """
    Storage Controller
    Example controller showing file upload/download with external storage
    """
    
    def index(self, request):
        """Show upload form and list uploaded files"""
        # Get list of files from storage
        try:
            files = Storage.files("uploads")
            
            # Get URLs for each file
            file_list = []
            for file_path in files:
                file_list.append({
                    'path': file_path,
                    'url': Storage.url(file_path),
                    'name': file_path.split('/')[-1]
                })
        except Exception as e:
            print(f"Error listing files: {e}")
            file_list = []
        
        return self.view("storage.index", request, {"files": file_list})
    
    async def upload(self, request):
        """Handle file upload - SIMPLIFIED VERSION"""
        try:
            print("=== Upload Request ===")
            
            # Try FastAPI way first (if available)
            if hasattr(request, 'form'):
                form = await request.form()
                print(f"Form parsed, keys: {list(form.keys())}")
            else:
                # Fallback to direct Starlette request
                if isinstance(request, Request):
                    form = await request.form()
                    print(f"Starlette form parsed, keys: {list(form.keys())}")
                else:
                    return {"error": "Cannot parse request"}
            
            if not form or "file" not in form:
                return {"error": "No file in form", "form_keys": list(form.keys()) if form else []}
            
            file = form["file"]
            print(f"âœ… File received!")
            print(f"Filename: {file.filename}")
            print(f"Content-Type: {file.content_type}")
            
            # Read file content
            file_content = await file.read()
            
            print(f"File size: {len(file_content)} bytes")
            
            # Generate path
            name, ext = os.path.splitext(file.filename)
            timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
            filename = f"{name}_{timestamp}{ext}"
            path = f"uploads/{filename}"
            
            # Store using Storage facade
            Storage.put(path, file_content)
            
            print(f"File uploaded to: {path}")
            
            # Get public URL
            file_url = Storage.url(path)
            
            print(f"File URL: {file_url}")
            
            return self.redirect("/storage")
            
        except Exception as e:
            error_trace = traceback.format_exc()
            print(f"Upload error: {error_trace}")
            return {"error": str(e), "traceback": error_trace}
    
    async def upload_fallback(self, request):
        """Fallback method using manual form parsing"""
        try:
            print("Using fallback manual form parsing...")
            
            # Debug: Check request details
            print(f"Request method: {request.method}")
            print(f"Request URL: {request.url}")
            print(f"Content-Type: {request.headers.get('content-type', 'N/A')}")
            
            # Check if request body is already consumed
            if hasattr(request, '_stream_consumed'):
                print(f"Stream consumed: {request._stream_consumed}")
            
            # Get uploaded file
            form = await request.form()
            
            # Debug logging
            print(f"Form keys: {list(form.keys())}")
            print(f"Form items count: {len(list(form.items()))}")
            
            if "file" not in form:
                return {
                    "error": "No file provided", 
                    "form_keys": list(form.keys()),
                    "content_type": request.headers.get('content-type', 'N/A'),
                    "method": request.method
                }
            
            file = form["file"]
            
            print(f"File object: {file}")
            print(f"Uploading file: {file.filename}")
            
            # Read file content
            file_content = await file.read()
            
            print(f"File size: {len(file_content)} bytes")
            
            # Generate path
            name, ext = os.path.splitext(file.filename)
            timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
            filename = f"{name}_{timestamp}{ext}"
            path = f"uploads/{filename}"
            
            # Store using Storage facade
            Storage.put(path, file_content)
            
            print(f"File uploaded to: {path}")
            
            return self.redirect("/storage")
            
        except Exception as e:
            error_trace = traceback.format_exc()
            print(f"Upload error: {error_trace}")
            return {"error": str(e), "traceback": error_trace}
    
    def show(self, request, path):
        """Serve a file (for local storage only)"""
        try:
            # Only works with local driver
            file_content = Storage.get(path)
            
            
            # Detect content type
            if path.endswith(('.jpg', '.jpeg')):
                content_type = 'image/jpeg'
            elif path.endswith('.png'):
                content_type = 'image/png'
            elif path.endswith('.gif'):
                content_type = 'image/gif'
            else:
                content_type = 'application/octet-stream'
            
            return Response(content=file_content, media_type=content_type)
            
        except Exception as e:
            return {"error": "File not found"}
    
    def delete(self, request, path):
        """Delete a file"""
        try:
            Storage.delete(path)
            return self.redirect("/storage")
        except Exception as e:
            return {"error": str(e)}

# ================================================================================
# File: app/Http/Controllers/TestController.py
# ================================================================================
class TestController(Controller):
    def index(self, request):
        return self.view("test", request)

# ================================================================================
# File: app/Http/Controllers/TodoController.py
# ================================================================================
# app/Http/Controllers/TodoController.py

engine = get_engine()
SessionLocal = sessionmaker(bind=engine)

class TodoController(Controller):
    def index(self, request):
        session = SessionLocal()
        todos = session.query(Todo).all()
        session.close()
        return self.view("todos.index", request, {"todos": todos})

    def create(self, request):
        return self.view("todos.create", request)

    async def store(self, request):
        data = await self.request(request)
        print("STORE DATA:", data)  # <-- debug
        session = SessionLocal()
        todo = Todo(name=data.get("name"))
        session.add(todo)
        session.commit()
        session.close()
        return self.redirect("/todos")

    def show(self, request, id):
        session = SessionLocal()
        todo = session.query(Todo).get(id)
        session.close()
        return self.view("todos.show", request, {"todo": todo})

    def edit(self, request, id):
        session = SessionLocal()
        todo = session.query(Todo).get(id)
        session.close()
        return self.view("todos.edit", request, {"todo": todo})

    async def update(self, request, id):
        data = await self.request(request)
        session = SessionLocal()
        todo = session.query(Todo).get(id)
        if todo:
            todo.name = data.get("name")
            session.commit()
        session.close()
        return self.redirect("/todos")

    def destroy(self, request, id):
        session = SessionLocal()
        todo = session.query(Todo).get(id)
        if todo:
            session.delete(todo)
            session.commit()
        session.close()
        return self.redirect("/todos")

# ================================================================================
# File: app/Http/Controllers/WelcomeController.py
# ================================================================================
"""
Welcome Controller
"""


class WelcomeController(Controller):
    """Handle welcome page"""
    
    async def index(self, request):
        """Show welcome page"""
        # Get current user if authenticated
        user = await get_current_user(request) if getattr(request.state, 'authenticated', False) else None
        
        return self.view('welcome', request, {'user': user})

# ================================================================================
# File: app/Models/Post.py
# ================================================================================
"""
Post Model
"""


class Post(Model):
    """Post model for content management"""
    
    table = "posts"
    
    fillable = [
        "user_id",
        "title",
        "slug",
        "content",
        "excerpt",
        "featured_image",
        "status",
        "published_at"
    ]
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
    
    @staticmethod
    def generate_slug(title: str) -> str:
        """Generate URL-friendly slug from title"""
        slug = title.lower()
        slug = re.sub(r'[^\w\s-]', '', slug)
        slug = re.sub(r'[-\s]+', '-', slug)
        return slug.strip('-')
    
    @classmethod
    async def create_post(cls, user_id: int, title: str, content: str, **kwargs):
        """Create a new post with auto-generated slug"""
        slug = kwargs.get('slug') or cls.generate_slug(title)
        
        # Ensure unique slug
        counter = 1
        original_slug = slug
        while await cls.where('slug', slug).first():
            slug = f"{original_slug}-{counter}"
            counter += 1
        
        data = {
            'user_id': user_id,
            'title': title,
            'slug': slug,
            'content': content,
            'excerpt': kwargs.get('excerpt', content[:200] if content else ''),
            'featured_image': kwargs.get('featured_image'),
            'status': kwargs.get('status', 'draft')
        }
        
        if kwargs.get('status') == 'published' and not kwargs.get('published_at'):
            data['published_at'] = datetime.now()
        
        return await cls.create(data)
    
    async def author(self):
        """Get the author of this post"""
        return await User.find(self.user_id)
    
    @classmethod
    async def published(cls):
        """Get only published posts"""
        return await cls.where('status', 'published').order_by('published_at', 'desc')
    
    @classmethod
    async def drafts(cls):
        """Get only draft posts"""
        return await cls.where('status', 'draft').order_by('created_at', 'desc')
    
    @classmethod
    async def by_user(cls, user_id: int):
        """Get posts by specific user"""
        return await cls.where('user_id', user_id).order_by('created_at', 'desc')
    
    def is_published(self) -> bool:
        """Check if post is published"""
        return self.status == 'published'
    
    def is_draft(self) -> bool:
        """Check if post is draft"""
        return self.status == 'draft'

# ================================================================================
# File: app/Models/Todo.py
# ================================================================================
# app/Models/Todo.py

Base = declarative_base()

class Todo(Base):
    __tablename__ = "todos"

    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String(255), nullable=False)
    created_at = Column(TIMESTAMP, default=datetime.utcnow)

# ================================================================================
# File: app/Models/User.py
# ================================================================================
"""
User Model
"""


class User(Model):
    """User model for authentication"""
    
    table = "users"
    
    fillable = [
        "name",
        "email",
        "password",
        "avatar",
        "role",
        "is_active"
    ]
    
    hidden = ["password"]
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
    
    @staticmethod
    def hash_password(password: str) -> str:
        """Hash a password using bcrypt"""
        # Convert password to bytes and hash with bcrypt
        password_bytes = password.encode('utf-8')
        salt = bcrypt.gensalt()
        hashed = bcrypt.hashpw(password_bytes, salt)
        return hashed.decode('utf-8')  # Return as string for database storage
    
    def verify_password(self, password: str) -> bool:
        """Verify password against hash"""
        if not hasattr(self, 'password') or not self.password:
            return False
        # Convert password and hash to bytes for comparison
        password_bytes = password.encode('utf-8')
        hash_bytes = self.password.encode('utf-8')
        return bcrypt.checkpw(password_bytes, hash_bytes)
    
    def is_admin(self) -> bool:
        """Check if user is admin"""
        return self.role == 'admin'
    
    def is_user(self) -> bool:
        """Check if user is regular user"""
        return self.role == 'user'
    
    def to_dict(self):
        """Convert user to dictionary (excluding password)"""
        data = super().to_dict()
        # Remove password from output
        data.pop('password', None)
        return data
    
    @classmethod
    async def find_by_email(cls, email: str):
        """Find user by email"""
        return await cls.where('email', email).first()
    
    @classmethod
    async def create_user(cls, name: str, email: str, password: str, role: str = 'user'):
        """Create a new user with hashed password"""
        hashed_password = cls.hash_password(password)
        return await cls.create({
            'name': name,
            'email': email,
            'password': hashed_password,
            'role': role,
            'is_active': True
        })
    
    async def posts(self):
        """Get all posts by this user"""
        return await Post.where('user_id', self.id).get()

# ================================================================================
# File: app/Providers/AppServiceProvider.py
# ================================================================================
class AppServiceProvider:
    def register(self, app):
        print("ðŸ”§ AppServiceProvider registered")
        # Register middleware
        app.add_middleware(MethodOverrideMiddleware)
        app.add_middleware(AuthMiddleware)

    def boot(self, app):
        print("ðŸš€ AppServiceProvider booted")

# ================================================================================
# File: app/Providers/AuthServiceProvider.py
# ================================================================================
class AuthServiceProvider:
    def register(self, app):
        print("ðŸ”‘ AuthServiceProvider registered")

    def boot(self, app):
        print("ðŸ” AuthServiceProvider booted")

# ================================================================================
# File: app/Providers/RouteServiceProvider.py
# ================================================================================
class RouteServiceProvider:
    def register(self, app):
        print("ðŸš RouteServiceProvider registered")
        
        # Register routes
        register_routes()
        
        # Use improved router
        app.include_router(Route.router)
        
        print(f"   âœ… Registered {len(Route._named_routes)} named routes")
        print(f"   âœ… Applied middleware to {len(Route._middleware_stack)} routes")

# ================================================================================
# File: app/Providers/ViewServiceProvider.py
# ================================================================================
class ViewServiceProvider:
    def register(self, app):
        env = Environment(
            loader=FileSystemLoader("resources/views"),
            autoescape=True
        )

        class ViewManager:
            def make(self, template, context=None):
                if context is None:
                    context = {}
                template = env.get_template(template + ".html")
                if "request" not in context:
                    raise ValueError("Missing 'request' in context. Required for 'url_for()' to work.")

                return template.render(**context)

        Facade._resolved["view"] = ViewManager()

# ================================================================================
# File: bootstrap/app.py
# ================================================================================
def create_app():
    app = FastAPI(
        title="Larathon",
        description="A Laravel-inspired Python web framework",
        version="1.0.0"
    )

    register_providers(app)

    # MOUNT STATIC FILES - try multiple possible locations
    _current_file_dir = os.path.dirname(os.path.abspath(__file__))
    _possible_static_paths = [
        os.path.join(_current_file_dir, "..", "public", "static"),  # bootstrap/../public/static
        os.path.join(os.getcwd(), "public", "static"),              # /project/public/static
        os.path.join(os.getcwd(), "api", "public", "static"),       # /var/task/api/public/static
        "public/static",                                             # relative fallback
    ]

    static_dir = None
    for path in _possible_static_paths:
        if os.path.exists(path) and os.path.isdir(path):
            static_dir = path
            break

    if static_dir:
        app.mount("/static", StaticFiles(directory=static_dir), name="static")

    return app


# Create app instance for uvicorn
app = create_app()

# ================================================================================
# File: bootstrap/providers.py
# ================================================================================
def register_providers(app):
    providers = [
        AppServiceProvider(),
        AuthServiceProvider(),
        RouteServiceProvider(),
        ViewServiceProvider(),
    ]

    for provider in providers:
        provider.register(app)

# ================================================================================
# File: routes/web.py
# ================================================================================
"""
Web Routes - Using Improved Router
Laravel-style routing with middleware, groups, and named routes
"""


def register_routes():
    """Register all application routes"""

    # =====================================
    # Public Routes
    # =====================================
    Route.get('/', WelcomeController, 'index').name('home')
    Route.get('/test', TestController, 'index').name('test')

    # =====================================
    # Authentication Routes
    # =====================================
    Route.get('/login', AuthController, 'show_login').name('login')
    Route.post('/login', AuthController, 'login')
    Route.get('/register', AuthController, 'show_register').name('register')
    Route.post('/register', AuthController, 'register')
    Route.get('/logout', AuthController, 'logout').name('logout')

    # =====================================
    # Protected Routes (Require Auth)
    # =====================================
    Route.middleware(['auth']).group(lambda: [
        # Dashboard
        Route.get('/dashboard', DashboardController, 'index').name('dashboard'),

        # Profile
        Route.get('/profile', AuthController, 'profile').name('profile'),

        # Posts Management
        Route.prefix('posts').name('posts.').group(lambda: [
            Route.get('/', PostController, 'index').name('index'),
            Route.get('/create', PostController, 'create').name('create'),
            Route.post('/', PostController, 'store').name('store'),
            Route.get('/{post_id}/edit', PostController, 'edit').name('edit'),
            Route.post('/{post_id}', PostController, 'update').name('update'),
            Route.post('/{post_id}/delete', PostController, 'destroy').name('destroy'),
        ]),

        # Storage Management
        Route.prefix('storage').name('storage.').group(lambda: [
            Route.get('/', StorageController, 'index').name('index'),
            Route.post('/upload', StorageController, 'upload').name('upload'),
            Route.delete('/delete/{path}', StorageController, 'delete').name('delete'),
        ]),
    ])

    # Todos (Resource)
    Route.resource('todos', TodoController),

    # =====================================
    # Admin Routes (Auth + Admin)
    # =====================================
    # Route.prefix('admin').middleware(['auth', 'admin']).name('admin.').group(lambda: [
    #     # Add admin routes here when needed
    # ])


def route(name: str, params: dict = None) -> str:
    """
    Generate URL from named route

    Usage:
        url = route('posts.show', {'post_id': 1})  # /posts/1
        url = route('dashboard')  # /dashboard
    """
    return Route.get_named_route(name, params)

# ================================================================================
# Application Entry Point for Vercel
# ================================================================================

# Vercel automatically detects and runs FastAPI apps
# Export 'app' instance directly - no wrapper needed
app = create_app()
