"""
Larathon Application Bundle
Auto-generated by: python artisan.py build
DO NOT EDIT THIS FILE MANUALLY
"""

# External Dependencies
from datetime import datetime
from dotenv import load_dotenv
from fastapi import APIRouter, Request
from fastapi import FastAPI
from fastapi import Request
from fastapi.responses import JSONResponse
from fastapi.responses import RedirectResponse
from fastapi.staticfiles import StaticFiles
from jinja2 import Environment, FileSystemLoader
from jinja2 import Environment, FileSystemLoader, select_autoescape
from sqlalchemy import Column, Integer, String, TIMESTAMP
from sqlalchemy import create_engine
from sqlalchemy.orm import declarative_base
from sqlalchemy.orm import sessionmaker
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy_utils import database_exists, create_database
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.templating import Jinja2Templates
import importlib
import importlib.util
import inspect
import os
import os, importlib.util
import psycopg2
import re


# ================================================================================
# File: config/app.py
# ================================================================================
APP_NAME = os.getenv("APP_NAME", "LaravelFastAPI")
APP_ENV = os.getenv("APP_ENV", "local")
APP_DEBUG = os.getenv("APP_DEBUG", "false").lower() == "true"
APP_PORT = int(os.getenv("APP_PORT", "8000"))

# ================================================================================
# File: config/database.py
# ================================================================================
def get_database_url():
    """
    Generate database URL based on DB_CONNECTION environment variable.
    Supports: sqlite, mysql, pgsql (PostgreSQL)
    """
    conn = os.getenv("DB_CONNECTION", "sqlite")

    if conn == "sqlite":
        db = os.getenv("DB_DATABASE", "database.sqlite")
        return f"sqlite:///{db}"

    elif conn == "mysql":
        user = os.getenv("DB_USERNAME", "root")
        pwd = os.getenv("DB_PASSWORD", "")
        host = os.getenv("DB_HOST", "127.0.0.1")
        port = os.getenv("DB_PORT", "3306")
        db = os.getenv("DB_DATABASE", "test")
        return f"mysql+pymysql://{user}:{pwd}@{host}:{port}/{db}"

    elif conn == "pgsql" or conn == "postgresql":
        user = os.getenv("DB_USERNAME", "postgres")
        pwd = os.getenv("DB_PASSWORD", "")
        host = os.getenv("DB_HOST", "127.0.0.1")
        port = os.getenv("DB_PORT", "5432")
        db = os.getenv("DB_DATABASE", "postgres")
        return f"postgresql+psycopg2://{user}:{pwd}@{host}:{port}/{db}"

    else:
        raise Exception(f"Unsupported DB_CONNECTION: {conn}. Supported: sqlite, mysql, pgsql")

def get_engine():
    """
    Create SQLAlchemy engine based on database configuration.
    """
    db_url = get_database_url()
    return create_engine(db_url)

# ================================================================================
# File: vendor/Illuminate/Console/Kernel.py
# ================================================================================
class Kernel:
    def __init__(self):
        self.commands = {
            "migrate": MigrateCommand(),
            "make:migration": MakeMigrationCommand(),
        }

    def handle(self, argv):
        if len(argv) < 2:
            print("‚ùå No command given")
            return

        cmd = argv[1]
        args = argv[2:]

        if cmd in self.commands:
            self.commands[cmd].handle(args)
        else:
            print(f"‚ùå Command {cmd} not found")

# ================================================================================
# File: vendor/Illuminate/Database/Connection.py
# ================================================================================
# Illuminate/Database/Connection.py

def get_engine(echo=False):
    db_url = get_database_url()
    engine = create_engine(db_url, echo=echo)

    if not database_exists(engine.url):
        print(f"‚ö° Database not found. Creating: {engine.url.database}")
        create_database(engine.url)

    return engine

# ================================================================================
# File: vendor/Illuminate/Database/Migrations/MigrationRunner.py
# ================================================================================
class MigrationRunner:
    def __init__(self):
        self.conn = psycopg2.connect(
            dbname=env("DB_DATABASE"),
            user=env("DB_USERNAME"),
            password=env("DB_PASSWORD"),
            host=env("DB_HOST"),
            port=env("DB_PORT"),
        )
        self.conn.autocommit = True
        self.cursor = self.conn.cursor()

        # Pastikan tabel migrations ada
        self.cursor.execute("""
            CREATE TABLE IF NOT EXISTS migrations (
                id SERIAL PRIMARY KEY,
                migration VARCHAR(255) NOT NULL UNIQUE,
                batch INT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)

    def run(self):
        migrations_path = os.path.join(os.getcwd(), "database/migrations")
        files = sorted([f for f in os.listdir(migrations_path) if f.endswith(".py")])

        # Ambil batch terakhir
        self.cursor.execute("SELECT COALESCE(MAX(batch), 0) FROM migrations")
        current_batch = self.cursor.fetchone()[0] + 1

        for file in files:
            migration_name = file.replace(".py", "")

            # cek apakah sudah dieksekusi
            self.cursor.execute("SELECT 1 FROM migrations WHERE migration = %s", (migration_name,))
            if self.cursor.fetchone():
                print(f"‚ö†Ô∏è Skipped: {migration_name} already migrated")
                continue

            print(f"üîº Running migration: {migration_name}")
            module = __import__(f"database.migrations.{migration_name}", fromlist=["Migration"])
            migration = module.Migration()
            migration.up(self.cursor)

            self.cursor.execute(
                "INSERT INTO migrations (migration, batch) VALUES (%s, %s)",
                (migration_name, current_batch),
            )

        self.cursor.close()
        self.conn.close()

# ================================================================================
# File: vendor/Illuminate/Database/Migrator.py
# ================================================================================
class Migrator:
    def __init__(self):
        self.engine = get_engine()
        self.migrations_path = os.path.join(os.getcwd(), "database", "migrations")

    def run(self):
        if not os.path.exists(self.migrations_path):
            print("‚ùå No migrations directory found.")
            return

        for file in sorted(os.listdir(self.migrations_path)):
            if file.endswith(".py") and file != "__init__.py":
                migration_name = file.replace(".py", "")
                file_path = os.path.join(self.migrations_path, file)

                spec = importlib.util.spec_from_file_location(migration_name, file_path)
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)

                if hasattr(module, "up"):
                    print(f"üîº Running migration: {migration_name}")
                    module.up(self.engine)
                else:
                    print(f"‚ö†Ô∏è No up() method in {migration_name}")

# ================================================================================
# File: vendor/Illuminate/Routing/Router.py
# ================================================================================
class Router:
    routes = []
    router = APIRouter()

    @classmethod
    def add(cls, method, path, controller=None, action=None):
        # regex untuk match route <id>
        pattern = "^" + re.sub(r"<(\w+)>", r"(?P<\1>[^/]+)", path) + "$"
        fastapi_path = path.replace("<", "{").replace(">", "}")

        cls.routes.append({
            "method": method.upper(),
            "path": path,
            "pattern": re.compile(pattern),
            "controller": controller,
            "action": action
        })

        async def endpoint(request: Request):
            path_params = request.path_params

            # --- Method Spoofing (Laravel style) ---
            if request.method == "POST":
                try:
                    form = await request.form()
                    if "_method" in form:
                        method_override = form["_method"].upper()

                        action_map = {
                            "PUT": "update",
                            "DELETE": "destroy"
                        }

                        if method_override in action_map:
                            # ‚úÖ simpan form ke request supaya bisa dipakai nanti
                            request.state._form = form

                            # üöÄ tentukan handler langsung
                            instance = controller()
                            handler = getattr(instance, action_map[method_override])
                            if inspect.iscoroutinefunction(handler):
                                return await handler(request, **path_params)
                            return handler(request, **path_params)
                except Exception as e:
                    print("‚ö†Ô∏è Spoofing error:", e)

            # --- CASE 1: closure langsung
            if callable(controller) and action is None:
                sig = inspect.signature(controller)
                args = {}
                for name, param in sig.parameters.items():
                    if name in path_params:
                        args[name] = path_params[name]
                    elif name == "request":
                        args[name] = request

                if inspect.iscoroutinefunction(controller):
                    return await controller(**args)
                return controller(**args)

            # --- CASE 2: controller class
            instance = controller()
            handler = getattr(instance, action)
            sig = inspect.signature(handler)
            args = {}
            for name, param in sig.parameters.items():
                if name in path_params:
                    args[name] = path_params[name]
                elif name == "request":
                    args[name] = request

            if inspect.iscoroutinefunction(handler):
                return await handler(**args)
            return handler(**args)

        # register ke FastAPI
        cls.router.add_api_route(
            fastapi_path,
            endpoint,
            methods=[method.upper()]
        )

    # Shortcut methods
    @classmethod
    def get(cls, path, controller=None, action=None):
        cls.add("GET", path, controller, action)

    @classmethod
    def post(cls, path, controller=None, action=None):
        cls.add("POST", path, controller, action)

    @classmethod
    def put(cls, path, controller=None, action=None):
        cls.add("PUT", path, controller, action)

    @classmethod
    def delete(cls, path, controller=None, action=None):
        cls.add("DELETE", path, controller, action)

    # resource style
    @classmethod
    def resource(cls, name, controller):
        base = f"/{name}"
        cls.get(base, controller, "index")
        cls.get(f"{base}/create", controller, "create")
        cls.post(base, controller, "store")
        cls.get(f"{base}/<id>", controller, "show")
        cls.get(f"{base}/<id>/edit", controller, "edit")
        cls.put(f"{base}/<id>", controller, "update")
        cls.delete(f"{base}/<id>", controller, "destroy")

    @classmethod
    def list_routes(cls):
        return cls.routes

Route = Router

# ================================================================================
# File: vendor/Illuminate/Support/Env.py
# ================================================================================
# tentukan root project (di mana artisan.py berada)
BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), "../../.."))
ENV_PATH = os.path.join(BASE_DIR, ".env")

# load file .env sekali
if os.path.exists(ENV_PATH):
    load_dotenv(ENV_PATH)

class Env:
    @staticmethod
    def get(key: str, default=None):
        return os.getenv(key, default)

# alias mirip Laravel
env = Env.get

# ================================================================================
# File: vendor/Illuminate/Support/Facades/App.py
# ================================================================================
class App:
    _bindings = {}

    @classmethod
    def bind(cls, key, instance):
        cls._bindings[key] = instance

    @classmethod
    def make(cls, key):
        return cls._bindings[key]

# ================================================================================
# File: vendor/Illuminate/Support/Facades/Facade.py
# ================================================================================
class FacadeMeta(type):
    def __getattr__(cls, name):
        root = cls.get_facade_root()
        if root is None:
            raise AttributeError(f"Facade root for '{cls.__name__}' is not set")
        return getattr(root, name)

    def __call__(cls, *args, **kwargs):
        root = cls.get_facade_root()
        if root is None:
            raise AttributeError(f"Facade root for '{cls.__name__}' is not set")
        return root(*args, **kwargs)


class Facade(metaclass=FacadeMeta):
    _resolved = {}

    @classmethod
    def get_facade_accessor(cls):
        raise NotImplementedError("Facade must implement get_facade_accessor")

    @classmethod
    def get_facade_root(cls):
        accessor = cls.get_facade_accessor()
        return cls._resolved.get(accessor)

    @classmethod
    def swap(cls, instance):
        accessor = cls.get_facade_accessor()
        cls._resolved[accessor] = instance

# ================================================================================
# File: vendor/Illuminate/Support/Facades/Response.py
# ================================================================================
# vendor/Illuminate/Support/Facades/Response.py

class Response:
    @staticmethod
    def json(data: dict, status: int = 200):
        return JSONResponse(content=data, status_code=status)

# helper global
def response(data: dict, status: int = 200):
    return Response.json(data, status)

# ================================================================================
# File: vendor/Illuminate/Support/Facades/Route.py
# ================================================================================
# vendor/Illuminate/Support/Facades/Route.py

class Route(Facade):
    @classmethod
    def get_facade_accessor(cls):
        return "router"

# ================================================================================
# File: vendor/Illuminate/Support/Facades/View.py
# ================================================================================
# vendor/Illuminate/Support/Facades/View.py

class View:
    @staticmethod
    def make(template: str, context: dict = {}):
        return BaseView.make(template, context)

def view(template: str, context: dict = {}):
    return View.make(template, context)

# ================================================================================
# File: vendor/Illuminate/Support/config_loader.py
# ================================================================================
BASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
ENV_PATH = os.path.join(BASE_DIR, ".env")

load_dotenv(dotenv_path=ENV_PATH)

def load_config():
    return {
        "APP_NAME": os.getenv("APP_NAME", "FastAPI App"),
        "APP_ENV": os.getenv("APP_ENV", "local"),
        "APP_DEBUG": os.getenv("APP_DEBUG", "false").lower() == "true",
        "APP_PORT": os.getenv("APP_PORT", "8000"),

        "DB_CONNECTION": os.getenv("DB_CONNECTION", "sqlite"),
        "DB_HOST": os.getenv("DB_HOST", "127.0.0.1"),
        "DB_PORT": os.getenv("DB_PORT", "3306"),
        "DB_DATABASE": os.getenv("DB_DATABASE", "database.sqlite"),
        "DB_USERNAME": os.getenv("DB_USERNAME", "root"),
        "DB_PASSWORD": os.getenv("DB_PASSWORD", ""),
    }

# ================================================================================
# File: vendor/Illuminate/View/View.py
# ================================================================================
# vendor/Illuminate/View/View.py

templates = Jinja2Templates(directory="resources/views")

class View:
    @staticmethod
    def make(template: str, context: dict = None):
        # default kosong
        context = context or {}
        if "request" not in context:
            raise ValueError('View.make() requires "request" in context')
        return templates.TemplateResponse(template.replace(".", "/") + ".html", context)

# ================================================================================
# File: vendor/Illuminate/View/ViewFactory.py
# ================================================================================
class ViewFactory:
    def __init__(self):
        # atur folder templates (resources/views)
        views_path = os.path.join(os.getcwd(), "resources", "views")
        self.env = Environment(
            loader=FileSystemLoader(views_path),
            autoescape=select_autoescape(['html', 'xml'])
        )

    def make(self, template, context=None):
        context = context or {}
        # laravel style: todos/index ‚Üí todos/index.html
        template_path = template + ".html"
        tpl = self.env.get_template(template_path)
        return tpl.render(**context)

# ================================================================================
# File: vendor/framework/config_loader.py
# ================================================================================
BASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
CONFIG_DIR = os.path.join(BASE_DIR, "config")

class Config:
    _cache = {}

    @classmethod
    def load(cls, name):
        if name in cls._cache:
            return cls._cache[name]

        file_path = os.path.join(CONFIG_DIR, f"{name}.py")
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"Config file not found: {name}.py")

        spec = importlib.util.spec_from_file_location(name, file_path)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)

        cls._cache[name] = getattr(module, "config", {})
        return cls._cache[name]

    @classmethod
    def get(cls, key, default=None):
        """
        key: "app.name" atau "database.default"
        """
        parts = key.split(".")
        if len(parts) < 2:
            raise ValueError("Config key must be in 'file.key' format")

        file, subkey = parts[0], ".".join(parts[1:])
        config = cls.load(file)

        value = config
        for part in subkey.split("."):
            value = value.get(part) if isinstance(value, dict) else None
        return value if value is not None else default

# ================================================================================
# File: vendor/framework/provider_manager.py
# ================================================================================
class ProviderManager:
    def __init__(self, providers):
        self.providers = providers
        self.instances = []

    def boot(self, app):
        for provider in self.providers:
            module_path, class_name = provider.rsplit(".", 1)
            module = importlib.import_module(module_path)
            cls = getattr(module, class_name)
            instance = cls()
            if hasattr(instance, "register"):
                instance.register(app)
            if hasattr(instance, "boot"):
                instance.boot(app)
            self.instances.append(instance)

# ================================================================================
# File: database/session.py
# ================================================================================
# database/session.py

engine = get_engine()
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# ================================================================================
# File: app/Http/Controllers/Controller.py
# ================================================================================
class Controller:
    def view(self, template: str, request, context: dict = None):
        context = context or {}
        context["request"] = request
        return View.make(template, context)

    def redirect(self, url: str, status_code: int = 303):
        """Laravel-style redirect helper"""
        return RedirectResponse(url=url, status_code=status_code)

    async def request(self, request):
        """Auto detect request JSON/Form dan ignore _method."""
        content_type = request.headers.get("content-type", "")
        print("üìå Content-Type:", content_type)   # üëà debug
        print("üìå Request method:", request.method)

        if "application/json" in content_type:
            data = await request.json()
            print("üì• JSON DATA:", data)   # üëà debug
            return data

        elif "application/x-www-form-urlencoded" in content_type or "multipart/form-data" in content_type:
            raw = await request.body()
            print("üì• RAW BODY:", raw.decode())
            form = await request.form()
            print("üì• RAW FORM:", form)
            data = {k: v for k, v in form.items() if k != "_method"}
            print("üì• CLEANED FORM DATA:", data)
            return data

        print("‚ö†Ô∏è Unknown body, returning empty dict")
        return {}

# ================================================================================
# File: app/Http/Controllers/PostController.py
# ================================================================================
class PostController(Controller):
    def index(self, request):
        return self.view("postcontroller.index", request)

    def create(self, request):
        return self.view("postcontroller.create", request)

    async def store(self, request):
        return {"message": "Store new PostController"}

    def show(self, request, id):
        return self.view("postcontroller.show", request, {"id": id})

    def edit(self, request, id):
        return self.view("postcontroller.edit", request, {"id": id})

    async def update(self, request, id):
        return {"message": f"Update {id} PostController"}

    def destroy(self, request, id):
        return {"message": f"Delete {id} PostController"}

# ================================================================================
# File: app/Http/Controllers/TestController.py
# ================================================================================
class TestController(Controller):
    def index(self, request):
        return self.view("test", request)

# ================================================================================
# File: app/Http/Controllers/TodoController.py
# ================================================================================
# app/Http/Controllers/TodoController.py

engine = get_engine()
SessionLocal = sessionmaker(bind=engine)

class TodoController(Controller):
    def index(self, request):
        session = SessionLocal()
        todos = session.query(Todo).all()
        session.close()
        return self.view("todos.index", request, {"todos": todos})

    def create(self, request):
        return self.view("todos.create", request)

    async def store(self, request):
        data = await self.request(request)
        print("STORE DATA:", data)  # <-- debug
        session = SessionLocal()
        todo = Todo(name=data.get("name"))
        session.add(todo)
        session.commit()
        session.close()
        return self.redirect("/todos")

    def show(self, request, id):
        session = SessionLocal()
        todo = session.query(Todo).get(id)
        session.close()
        return self.view("todos.show", request, {"todo": todo})

    def edit(self, request, id):
        session = SessionLocal()
        todo = session.query(Todo).get(id)
        session.close()
        return self.view("todos.edit", request, {"todo": todo})

    async def update(self, request, id):
        data = await self.request(request)
        session = SessionLocal()
        todo = session.query(Todo).get(id)
        if todo:
            todo.name = data.get("name")
            session.commit()
        session.close()
        return self.redirect("/todos")

    def destroy(self, request, id):
        session = SessionLocal()
        todo = session.query(Todo).get(id)
        if todo:
            session.delete(todo)
            session.commit()
        session.close()
        return self.redirect("/todos")

# ================================================================================
# File: app/Http/Controllers/WelcomeController.py
# ================================================================================
class WelcomeController(Controller):
    def index(self, request):
        # render resources/views/welcome.html
        return self.view("welcome", request)

# ================================================================================
# File: app/Http/Middleware/MethodOverrideMiddleware.py
# ================================================================================
class MethodOverrideMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        if request.method == "POST":
            try:
                form = await request.form()
                # hanya override jika ada _method dan nilainya valid
                if "_method" in form:
                    method_override = form["_method"].upper()
                    if method_override in ("PUT", "DELETE", "PATCH"):
                        request.scope["method"] = method_override
            except Exception:
                pass
        return await call_next(request)

# ================================================================================
# File: app/Models/Post.py
# ================================================================================
class Post:
    def __init__(self):
        pass

# ================================================================================
# File: app/Models/Todo.py
# ================================================================================
# app/Models/Todo.py

Base = declarative_base()

class Todo(Base):
    __tablename__ = "todos"

    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String(255), nullable=False)
    created_at = Column(TIMESTAMP, default=datetime.utcnow)

# ================================================================================
# File: app/Providers/AppServiceProvider.py
# ================================================================================
class AppServiceProvider:
    def register(self, app):
        print("üîß AppServiceProvider registered")
        app.add_middleware(MethodOverrideMiddleware)

    def boot(self, app):
        print("üöÄ AppServiceProvider booted")

# ================================================================================
# File: app/Providers/AuthServiceProvider.py
# ================================================================================
class AuthServiceProvider:
    def register(self, app):
        print("üîë AuthServiceProvider registered")

    def boot(self, app):
        print("üîê AuthServiceProvider booted")

# ================================================================================
# File: app/Providers/RouteServiceProvider.py
# ================================================================================
class RouteServiceProvider:
    def register(self, app):
        # buat instance Router
        router_instance = Router()

        # swap ke facade
        Route.swap(router_instance)

        # load definisi routes
        register_routes()

        # setelah semua route terdaftar, baru include ke FastAPI
        app.include_router(router_instance.router)

# ================================================================================
# File: app/Providers/ViewServiceProvider.py
# ================================================================================
class ViewServiceProvider:
    def register(self, app):
        env = Environment(
            loader=FileSystemLoader("resources/views"),
            autoescape=True
        )

        class ViewManager:
            def make(self, template, context=None):
                if context is None:
                    context = {}
                template = env.get_template(template + ".html")
                if "request" not in context:
                    raise ValueError("Missing 'request' in context. Required for 'url_for()' to work.")

                return template.render(**context)

        Facade._resolved["view"] = ViewManager()

# ================================================================================
# File: bootstrap/app.py
# ================================================================================
def create_app():
    app = FastAPI()

    register_providers(app)

    # MOUNT STATIC FILES - try multiple possible locations
    _current_file_dir = os.path.dirname(os.path.abspath(__file__))
    _possible_static_paths = [
        os.path.join(_current_file_dir, "public", "static"),     # api/public/static
        os.path.join(os.getcwd(), "api", "public", "static"),    # /var/task/api/public/static
        os.path.join(os.getcwd(), "public", "static"),           # /var/task/public/static
        "public/static",                                          # relative fallback
    ]

    static_dir = None
    for path in _possible_static_paths:
        if os.path.exists(path) and os.path.isdir(path):
            static_dir = path
            break

    if static_dir:
        app.mount("/static", StaticFiles(directory=static_dir), name="static")

    return app


# Don't create app instance at module level - let the entry point handle it
# This prevents issues with bundling and allows proper initialization order

# ================================================================================
# File: bootstrap/providers.py
# ================================================================================
def register_providers(app):
    providers = [
        AppServiceProvider(),
        AuthServiceProvider(),
        RouteServiceProvider(),
        ViewServiceProvider(),
    ]

    for provider in providers:
        provider.register(app)

# ================================================================================
# File: routes/web.py
# ================================================================================
# routes/web.py

def register_routes():
    """Register all application routes - called by RouteServiceProvider"""
    Route.get("/", WelcomeController, "index")
    Route.get("/test", TestController, "index")
    Route.resource("todos", TodoController)
    Route.resource("posts", PostController)

# ================================================================================
# Application Entry Point for Vercel
# ================================================================================

# Create FastAPI app instance
_app = create_app()

# Wrap with Mangum for serverless compatibility
from mangum import Mangum
handler = Mangum(_app, lifespan="off")

# Export app for direct access (local development)
app = _app
